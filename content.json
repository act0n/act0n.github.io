{"pages":[{"title":"关于我","text":"我是一条咸鱼","link":"/about/index.html"}],"posts":[{"title":"Express中配置https","text":"微信小程序要想发布就需要配置域名，而且必须是https，所以就根据自己的探索经历记录下来 流程阿里云网站上的流程指示： 申请、下载证书 登录阿里云，搜索SSL证书，然后点击管理控制台 点击SSL证书，立即购买，个人的可以使用免费的 之后创建证书然后证书申请 一系列内容填写之后就能获取到已签发的证书了，然后可以对于自己的服务器下载相应的证书，由于我们是node来搭建的服务器，所以下载其他即可 将下载的两个文件，放置到express应用实例的根目录下的key文件夹（当然，你们可以自定义，只要找得到这俩文件） 设置Expressexpress默认是http，并且express内置了https核心模块文件，所以我们要用https也很简单，直接引入、配置即可 这是我的app.js文件 123456789101112131415161718const express = require('express')const fs = require('fs')const app = express()const http = require('http')const https = require('https')//8080端口开启httphttp.createServer(app).listen(8080, &quot;0.0.0.0&quot;,() =&gt; { console.log('Running 8080 ...')})const options = { key: fs.readFileSync('./key/server.key'), cert: fs.readFileSync('./key/server.pem')}//8443端口开启httpshttps.createServer(options, app).listen(8443, '0.0.0.0',() =&gt; { console.log('Running 8443 ...')}) 重启之后就可以了 生成 如果有的小伙伴想自己生成然后设置，也很简单 生成key和cert 1openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365 有点不太的就是文件名和类型可能有点不同，但是实质都一样，设置即可 1234const options = { key: fs.readFileSync('./key/key.pem'), cert: fs.readFileSync('./key/cert.pem')} 其他内容跟上面讲的均相同 参考链接Express 配置https nodejs配置 https服务","link":"/ConfigHttpsInExpress/"},{"title":"数据结构笔记","text":"数据结构 “唯一可以确定的是，明天会使我们所有人大吃一惊” ——阿尔文·托夫勒 数据结构的基本概念 基本概念数据 数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料。 数据元素、数据项 数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。 数据结构、数据对象 数据结构是相互之间存在一种或多种特定关系的数据元素的集合。数据对象是具有相同性质的数据元素的集合，是数据的一个子集。 数据类型、抽象数据类型（ADT） 数据类型是一个值的集合和定义在此集合上的一组操作的总称 原子类型。其值不可再分的数据类型。 结构类型。其值可以再分解为若干成分（分量）的数据类型。 抽象数据类型是抽象数据组织及与之相关的操作。 ADT用数学化的语言定义数据的逻辑结构、定义运算。与具体的实现无关。 三要素逻辑结构 集合 各个元素同属一个集合，别无其它关系 线性结构 数据元素之间是一对一的关系。除了第一个元素，所有元素都有唯一前驱；除了最后一个元素，所有元素都有唯一后继 树形结构 数据元素之间是一对多的关系 图状结构（网状结构） 数据元素之间是多对多的关系 物理结构（存储结构） 顺序存储 把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。 链式存储 逻辑上相邻的元素在物理位置上可以不相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。 索引存储 在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式是（关键字，地址） 散列存储 根据元素的关键字直接计算出该元素的存储地址，又称哈希（Hash）存储 数据的运算 运算的定义 是针对逻辑结构的，指出运算的功能 运算的实现 是针对存储结构的，指出运算的具体操作步骤 算法 特性 有穷性 一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。 算法必须是有穷的，而程序可以是无穷的 确定性 算法中每条指令必须有确切的含义，对于相同的输入只能得到相同的输出 可行性 算法中描述的操作都可以通过以及实现的基本运算执行有限次来实现。 输入 一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。 输出 一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。 效率 时间复杂度 事前预估算法时间开销T(n)与问题规模n的关系 可以只考虑阶数高的部分 ‘O’表示“同阶”，同等数量级。即：n-&gt;∞时，二者之比为常熟 时间复杂度口诀：常对幂指阶 注意！算法的性能问题只有在n很大的时候才会暴露出来 结论 顺序执行的代码只会影响常数项，可以忽略 只需挑循环中的一个基本操作分析它的的执行次数与n的关系 如果有多层嵌套循环，只需关注最深层的循环进行循环了几次 总结 空间复杂度 总结 线性表顺序表单链表特殊链表栈和队列栈队列数组矩阵串串的模式匹配KMP算法树二叉树线索二叉树二叉排序树平衡二叉树哈夫曼树图邻接矩阵法邻接表法十字链表邻接多重表广度优先、深度优先查找顺序查找折半查找分块查找B树、B+树散列表排序直接插入排序折半插入排序希尔排序冒泡排序快速排序直接选择排序堆排序归并排序基数排序","link":"/Data-structure-notes/"},{"title":"Hexo + Docker 搭建博客","text":"前提Linux服务器 保证自己服务器上的端口对外开放，即设置相应的防火墙规则 安装好hexo 安装：npm install hexo-cli -g 初始化搭建：hexo init myBlog,myBlog 是自己设置的名字，即为生成的文件夹 进入文件夹，添加依赖：cd myBlog npm install 完成了hexo的安装和初始化，为了能进行本地预览 安装hexo-server：sudo npm install hexo-server 生成静态页面并打开本地服务：hexo generate(或hexo g)hexo server(或hexo s) 根据提示，进入http://localhost:4000/ 安装好docker 首先需要在自己的Linux服务器上面安装好docker，详细安装过程请查看**&gt;&gt;&gt;** 搭建服务器，我以apache示范，其他的请自行百度 拉取镜像：docker pull httpd 关键共享文件 由于执行hexo generate(或hexo g)后，会生成一个放到一个public文件中，所以需要把该文件夹与docker容器内的首页文件夹实现共享，这样我们修改public内文件(即执行 hexo g)后，能够实时更新; 执行：docker run --name apache -v /home/myBlog/public/:/usr/local/apache2/htdocs/ -p 80:80 -d httpd 浏览器中输入服务器的ip地址或者域名，即可查看。 注意： 这相当于监听public文件，切忌执行`hexo clean`，因为这会清除掉缓存和依赖，同时也会把public文件夹删除掉，然后docker监听不到public文件夹，就无法打开网站。 解决方法：：重新启动下docker下的apache容器 docker stop myBlog myBlog是指容器id docker start myBlog 扩展–更换主题了解主题目录结构 myBlog //博客根目录 _config.yml //博客配置文件themes //主题目录 landscape //默认主题 _config.yml //对应主题的配置文件 下载安装 以 **hexo-theme-material**举例 cd themes git clone https://github.com/bolnh/hexo-theme-material.git material 或 npm install hexo-material cd themes cp -r node_modules/hexo-material material 配置 进入myBlog/themes/material/，看该目录下的是否有 _config.yml ，没有就把 _config.template.yml文件copy一份，重命名为_config.yml 再进入myBlog/，打开_config.yml ，把其中的themes 字段后的值设置为主题文件名 比如：我上面设置的主题文件明是 material，那么就需要设置为material # Extensions ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: &lt;主题文件夹的名称&gt; 然后直接hexo g即可 另外，如果想了解更多关于hexo执行的指令，可以查看hexo中文网-指令 缺点使用material主题的话，我们的主题配置文件是在对应的主题目录下的，我们上传到GitHub上面的话，这个主题文件会被舍弃，所以就很麻烦：我们辛辛苦苦配置的内容需要重新下载安装。 因此，我就更换主题为：icarus。 它的配置目录就在博客根目录，如果其他主题也可以这样设置的话，推荐使用这种。 12345678|-- node_modules/|-- public/|-- scaffolds/|-- source/|-- themes/|-- _config.icarus.yml //对应主题配置文件|-- _config.post.yml //对应发表博文的配置文件|-- _config.yml //对应网站系统配置文件 参考资料 Linux下使用Hexo搭建github博客最全Hexo博客搭建+主题优化+插件配置+常用操作+错误分析","link":"/Docker&Hexo-build-blog/"},{"title":"Docker笔记总结","text":"Docker安装部署CentOS yum 包更新到最新（花的时间比较多） 1yum update 安装需要的软件包，yum-util 提供的yum-config-manager功能，另外两个是devicemapper驱动依赖的 1yum install -y yum-utils device-mapper-persistent-data lvm2 设置yum源 12yum-confi-manager \\--add-repo https://download.docker.com/linux/centos/docker-ce.repo 安装docker，出现输入的页面都按 y 1yum install -y docker-ce 查看docker版本，验证是否安装成功 1docker -v 其他安装方式(推荐) 教程链接：Here! Docker命令Docker服务相关命令 启动docker服务 12systemctl start dockersystemctl start docker 停止docker服务 1systemctl stop docker 重启docker服务 1systemctl restart docker 查看docker服务状态 1systemctl status docker 设置开机启动docker服务 1systemstl enable docker Docker镜像相关命令 查看镜像：查看本地所有的镜像 12docker imagesdocker images -q # 查看所有镜像id 搜索镜像：从网络中查找需要的镜像 1docker search 镜像名称 拉取镜像：从docker仓库下载镜像到本地，镜像名称格式为 名称:版本号，如果版本号不指定则是最新版本。如果不知道镜像版本，可以去docker hub 搜索对应镜像查看 1docker pull 镜像名称 删除镜像 12docker rmi 镜像iddocker rmi `docker images -q` # 删除所有本地镜像 Docker容器相关的命令 查看容器 12docker ps # 查看正在运行的容器docker ps -a # 查看所有容器 创建并启动容器 123456docker run 参数docker run \\ --name apache \\-v /home/myBlog/public/:/usr/local/apache2/htdocs/ \\-p 80:80 \\-d httpd 参数说明： –name：为创建的容器命名。 -v：设置数据卷。前者是宿主机的目录，后者是容器内的目录。 -i：保持容器运行。通常与-t同时使用。加入it这两个参数后，容器创建后自动进入容器中，退出容器后，容器自动关闭。 -t：为容器重新分配一个伪输入终端，通常与-i同时使用。 -d：以守护（后台）模式运行容器。创建一个容器在后台运行，需要使用docker exec进入容器。退出时，容器不会关闭。 -it：创建的容器一般称为交互式容器。 -id：创建的容器一般称为守护式容器。 -p：端口映射。前者是宿主机端口，后者是容器端口。 httpd：指用httpd镜像为基础启动容器。 1docker run -it --rm ubuntu:16.04 bash 参数说明 –rm：这个参数是说容器退出后随之将其删除 ubuntu:16.04：这是指用ubuntu:16.04镜像为基础来启动容器。 bash：放在镜像名后的是命令，这里我们希望有个交互式shell,因此用的是bash。 进入容器 123456docker exec 容器名称 操作命令等参数 # 退出容器，容器不会关闭 ，而且# 例如：我要查看myblog为名称的容器的路径/usr/local/apache2docker exec myblog ls /usr/loacl/apache2 # 例如：我要进入myblog为名称的容器内用bash操作docker exec myblog -it /bin/bash 参数说明 保持容器运行。通常与-t同时使用。加入it这两个参数后，容器创建后自动进入容器中，退出容器后，容器自动关闭。 -t：为容器重新分配一个伪输入终端，通常与-i同时使用。 -it：创建的容器一般称为交互式容器。 启动容器 1docker start 容器名称 停止容器 1docker stop 容器名称 删除容器：如果容器是运行状态则删除失败，需要停止容器才能删除 1docker rm 容器名称 查看容器信息 1docker inspect 容器名称 导入容器 1234567docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]# filedocker import /path/to/exampleimage.tgz# -cat exampleimage.tgz | docker import - exampleimagelocal:new# URLdocker import http://study.163.com/image.tgz example/imagerepo 导出容器 1docker export 容器名称 &gt; 导出文件名.tar Docker容器的数据卷数据卷概念和作用思考 Docker容器删除后，在容器中产生的数据也会随之销毁吗？ 会。 Docker容器和外部机器可以直接交换文件吗？ 不可以。 容器之间想要进行数据交互？ 不可以。 那咋办嘛？这就要用到数据卷了 数据卷 数据卷是宿主机中的一个目录或文件 当容器目录和数据卷目录绑定后，对方的修改会立即同步 一个数据卷可以被多个容器同时挂载 一个容器也可以被挂载多个数据卷 数据卷的作用 容器数据持久化 外部机器和容器间接通信 容器之间数据交换 配置数据卷 创建启动容器时，使用-v参数设置数据卷 docker run ...-v 宿主机目录(文件):容器内目录(文件)... 注意事项： 目录必须是绝对路径 如果目录不存在，会自动创建 可以挂载多个数据卷 数据卷容器配置数据卷容器 创建启动c3数据卷容器，使用-v参数设置数据卷 docker run -it --name=c3 -v /volume centos:7 /bin/bash 创建启动c1 c2数据卷容器，使用-volumes-from参数设置数据卷 docker run -it --name=c1 -volumes-from c3 centos:7 /bin/bash docker run -it --name=c2 -volumes-from c3 centos:7 /bin/bash Docker应用部署MySQL部署 搜索MySQL镜像 docker search mysql 拉取MySQL镜像 docker pull mysql:5.6 创建容器，设置端口映射、目录映射 # 在/root目录下创建mysql目录用于存储mysql数据信息 mkdir ~/mysql cd ~/mysql docker run -id \\ --name=c_mysql \\ -p 3307:3306 \\ -v $PWD/conf:/etc/mysql/confi.d \\ -v $PWD/logs:/logs \\ -v $PWD/data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=123456 \\ mysql:5.6 参数说明： -p 3307:3306：将容器的3306端口映射到宿主机的3307端口。 -v $PWD/conf:/etc/mysql/confi.d：将主机当前目录下的conf/my.cnf挂载到容器的/etc/mysql/my.cnf。配置目录 -v $PWD/logs:/logs：将主机当前目录下的logs目录挂载到容器的/logs。日志目录 -v $PWD/data:/var/lib/mysql：将主机当前目录下的data目录挂载到容器的/var/lib/mysql。数据目录 -e MYSQL_ROOT_PASSWORD=123456：初始化root用户的密码。 Tomcat部署 搜索Tomcat镜像 docker search tomcat 拉取Tomcat镜像 docker pull tomcat 创建容器，设置端口映射、目录映射 # 在/root目录下创建tomcat目录用于存储tomcat数据信息 mkdir ~/tomcat cd ~/tomcat docker run -id \\ --name=c_tomcat \\ -p 8080:8080 \\ -v $PWD:/usr/local/tomcat/webapps \\ tomcat 参数说明： -p 8000:8080：将容器的8080端口映射到宿主机的8000端口。 -v $PWD:/usr/local/tomcat/webapps：将主机当前目录挂载到容器的/usr/local/tomcat/webapps。 Nginx部署 搜索Nginx镜像 docker search nginx 拉取Nginx镜像 docker pull nginx 创建容器，设置端口映射、目录映射 1234567# 在/root目录下创建nginx目录用于存储nginx数据信息mkdir ~/nginxcd ~/nginxmkdir confcd conf# 在~/nginx/conf/下创建nginx.conf文件，粘贴下面内容vim nginx.conf 1234567891011121314151617181920212223242526272829user nginx;worker_processes 1;error_log /var/log/nginx/error.log warn;pid /var/run/nginx.pid;events { worker_connections 1024;}http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] &quot;$request&quot; ' '$status $body_bytes_sent &quot;$http_referer&quot; ' '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf;} 1234567docker run -id \\ --name=c_nginx \\ -p 81:80 \\ -v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf \\ -v $PWD/logs:/var/log/nginx \\ -v $PWD/html:/usr/share/nginx/html \\ nginx 参数说明： -p 81:80：将容器的80端口映射到宿主机的81端口。 -v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf：将主机当前目录下的/conf/nginx.conf挂载到容器的/etc/nginx/nginx.conf。配置目录 -v $PWD/logs:/var/log/nginx：将主机当前目录下的logs目录挂载到容器的/var/log/nginx。日志目录 -v $PWD/html:/usr/share/nginx/html：将主机当前目录下的/html挂载到容器的/usr/share/nginx/html。 Redis部署 搜索Redis镜像 1docker search redis 拉取Redis镜像 1docker pull redis:5.0 创建容器，设置端口映射、目录映射 1docker run -id --name=c_redis -p 6379:6379 redis:5.0 参数说明： -p 6379:6379：将容器的6379端口映射到宿主机的6379端口。 使用外部机器连接redis 1./redis-cli.exe -h &lt;your ipAddress&gt; -p 6379 DockerfileDocker镜像原理思考 Docker镜像本质是什么？ 是一个分层的文件系统 Docker中一个centos镜像为什么只有200MB，而一个centos操作系统的iso文件要几个GB？ Centos的iso镜像文件包含bootfs和rootfs，而docker的centos镜像复用操作系统的bootfs，只包含rootfs和其他镜像层 Docker中一个tomcat镜像为什么有500MB，而一个tomcat安装包只有70多MB？ 由于docker中镜像是分层的，tomcat虽然只有70多MB，但它需要依赖于父镜像和子镜像，所有整个对外暴露的tomcat镜像大小有500多MB Linux文件系统 bootfs：包含bootloader（引导加载系统）和kernel（内核） rootfs：root文件系统，包含的就是典型的Linux系统中的/dev，/proc，/bin，/etc等标准目录和文件 不用的Linux发行版，bootfs基本一样，而rootfs不同，如Ubuntu，centos等 Docker镜像 Docker镜像是由特殊的文件系统叠加而成 最底端是bootfs,并使用宿主机的bootfs 第二层是root文件系统rootfs,称为base image 然后再往上可以叠加其他的镜像文件 ***统一文件系统(Union File System)***技术能够将不同的层整合成一个文件系统,为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来,只存在一个文件系统。 一个镜像可以放在另一个镜像的上面。位于下面的镜像称为父镜像，最底部的镜像成为基础镜像。 当从一个镜像启动容器时，Docker会从最顶层加载一个读写文件系统作为容器 镜像制作 容器转为镜像 123docker commit 容器id 镜像名称:版本号 # 将容器转换为镜像文件docker save -o 压缩文件名称 镜像名称:版本号 # 将镜像文件打包成压缩文件，之后就能对压缩文件传送了docker load -i 压缩文件名称 # 将压缩文件解压称为镜像文件 Dockerfile 看下面内容 Dockerfile概念及作用概念 Dockerfile是一个文本文件 包含了一条条的指令 每一条指令构建一层，基于基础镜像，最终构建出一个新的镜像 对于开发人员：可以为开发团队提供一个完全一致的开发环境 对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了 对于运维人员：在部署时，可以实现应用的无缝移植 Dockerfile关键字列举一些常用的 FROM &lt;image name&gt;: 指定构建使用的基础镜像 例: FROM ubuntu:14.04 MAINTAINER &lt;author name&gt;: 创建者信息 例: MAINTAINER adyo &quot;xxxx@qq.com&quot; ENV: 设置环境变量 例: ENV REFRESHED _AT 2017-03-16 RUN &lt;command&gt;: 在shell或者exec的环境下执行一条命令.RUN指令会在新创建的镜像上添加新的层面，接下来提交的结果可以用在Dockerfile的下一条指令中 例: RUN apt-get -yqq update ADD &lt;source&gt; &lt;destination&gt;: 从当前目录复制文件到容器, source可以是URL或者是启动配置上下文中的一个文件, destination是容器内的路径. 会自动处理目录, 压缩包等情况 例: `` COPY &lt;source&gt; &lt;destination&gt;: 从当前目录复制文件到容器. 只是单纯地复制文件. 例：COPY index.html /var/www/html VOLUME [ &quot;/data&quot; ]: 声明一个数据卷, 可用于挂载, []里面是路径 例: VOLUME [ &quot;/var/lib/redis&quot;, &quot;/var/log/redis&quot; ] USER &lt;uid&gt;: 镜像正在运行时设置的一个UID,RUN命令执行时的用户 WORKDIR: 指定RUN、CMD与ENTRYPOINT命令的工作目录 例: WORKDIR /opt/nodeapp ONBUILD: 前缀命令, 放在上面这些命令前面, 表示生成的镜像再次作为”基础镜像”被用于构建时要执行的命令 ENTRYPOINT: 配置给容器一个可执行的命令,这意味着在每次使用镜像创建容器时一个特定的应用程序可以被设置为默认程序.同时也意味着该镜像每次被调用时仅能运行指定的应用.类似于CMD,Docker只允许一个ENTRYPOINT,多个ENTRYPOINT会只执行最后的ENTRYPOINT指令 例: ENTRYPOINT [ &quot;nodejs&quot;, &quot;server.js&quot; ] CMD: 提供了容器默认的执行命令,Dockerfile只允许使用一次CMD指令. 使用多个CMD只有最后一个指令生效 例: CMD [ &quot;/bin/true&quot; ] EXPOSE &lt;port&gt;: 指定容器在运行时监听的端口 例: EXPOSE 3000 附加： 如果对与ADD 与 COPY有疑惑或者不太会区分的话，可以参考此篇文章，这篇文章讲得很细节了： Docker ADD vs. COPY: What are the Differences? 制作自定义centos镜像自定义需求 默认登录路径为/usr 可以使用vim 操作 创建编辑dockerfile文件 123mkdir /root/dockerfilecd dockerfilvim centos_dockerfile 定义父镜像：FROM centos:7 定义作者信息：MAINTAINER adongyo &lt;adongyo@it.cn&gt; 执行安装vim命令：RUN yum install -y vim 定义默认的工作目录：WORKDIR /usr 定义容器启动执行的命令：CMD /bin/bash 执行命令 1docker build -f ./centos_dockerfile -t myCentos:1 . 参数说明： -f： 指定dockerfile文件 -t： 设置生成的新的镜像的名称 .： 别漏了后面还有一个’.’ 参考资料 b站转载黑马程序员","link":"/Docker-learning-notes/"},{"title":"Docker多容器应用","text":"前言:wind_face: 本篇文章大部分是docker的官方英文文档内的内容，自己对这些内容进行了尝试，然后加了一些自己的解释和实践。这是比较简单的多容器应用，未来会再尝试构建更复杂的多容器应用的。 我们一直在使用单容器应用程序。但是，我们现在想要将 MySQL 添加到应用程序中。经常会出现下面的问题——“MySQL会在哪里运行？安装在同一个容器中还是单独运行？” Tips：如果想了解单容器应用或者更多基础内容，可以看 Our-application、Docker-learning-notes 一般来说，每个容器都应该做一件事，并且做好。 因此，我们将更新我们的应用程序，使其工作如下： 容器网络要记住，默认情况下，容器是独立运行的，并且对同一台机器上的其他进程或容器一无所知。那么，我们如何让一个容器与另一个容器通信呢？答案是网络。 如果两个容器在同一个网络上，它们可以相互通信。如果他们不在，他们就不能相互通信。 启动 MySQL有两种方法可以将容器放在网络上： 在开始时分配它 连接现有的容器 现在，我们将首先创建网络并在启动时附加 MySQL 容器。 创建网络。 1docker network create todo-app 启动一个 MySQL 容器并将其连接到网络。我们还将定义一些数据库将用于初始化数据库的环境变量（请参阅MySQL Docker Hub 列表中的“环境变量”部分）。 123456docker run -d \\ --network todo-app --network-alias mysql \\ -v todo-mysql-data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=secret \\ -e MYSQL_DATABASE=todos \\ mysql:5.7 如果你使用的是 PowerShell，请使用此命令。 123456docker run -d ` --network todo-app --network-alias mysql ` -v todo-mysql-data:/var/lib/mysql ` -e MYSQL_ROOT_PASSWORD=secret ` -e MYSQL_DATABASE=todos ` mysql:5.7 -d：daemon简写，表示后台运行 –network todo-app：选择之前创建的网络名称 –network-alias mysql：设置别名 -v todo-mysql-data:/var/lib/mysql：设置数据卷，前者为宿主机文件，后者为容器内文件 -e MYSQL_ROOT_PASSWORD=secret ：设置数据库root用户的密码 -e MYSQL_DATABASE=todos： 创建一个名为todos的数据库 mysql:5.7：选择mysql:5.7的镜像image 我们指定了--network-alias标志。稍后我们会回到这个话题。 提示 注意到我们使用了一个名为todo-mysql-datahere的卷并将其安装在/var/lib/mysql，这是 MySQL 存储其数据的地方。但是，我们从未运行过docker volume create命令。Docker 识别出我们想要使用命名卷并自动为我们创建一个。 要确认我们已启动并运行数据库，请连接到数据库并验证它已连接。 1docker exec -it &lt;mysql-container-id&gt; mysql -p 当密码提示出现时，输入secret。在 MySQL shell 中，列出数据库并验证是否看到了todos数据库。 1mysql&gt; SHOW DATABASES; 会看到如下所示的输出： 12345678910+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys || todos |+--------------------+5 rows in set (0.00 sec) 欧耶！我们有我们的todos数据库，可以使用了！ 连接到 MySQL现在我们知道 MySQL 已启动并运行，让我们使用它！但是，问题是……如何？如果我们在同一网络上运行另一个容器，我们如何找到该容器（记住每个容器都有自己的 IP 地址）？ 为了解决这个问题，我们将使用nicolaka/netshoot容器，它附带了许多可用于故障排除或调试网络问题的工具。 感觉这一步来创建这个新容器有点多余，其实你们可以不用弄，这里是为了解释这个主机名的由来 使用 nicolaka/netshoot 镜像启动一个新容器。确保将其连接到同一网络。 1docker run -it --network todo-app nicolaka/netshoot 在容器内部，我们将使用dig命令，这是一个有用的 DNS 工具。我们将查找主机名的 IP 地址mysql。 1dig mysql 你会得到这样的输出…… 实例的输出： 12345678910111213141516; &lt;&lt;&gt;&gt; DiG 9.14.1 &lt;&lt;&gt;&gt; mysql;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 32162;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0;; QUESTION SECTION:;mysql. IN A;; ANSWER SECTION:mysql. 600 IN A 172.23.0.2;; Query time: 0 msec;; SERVER: 127.0.0.11#53(127.0.0.11);; WHEN: Tue Oct 01 23:47:24 UTC 2019;; MSG SIZE rcvd: 44 我的输出： 1234567891011121314151617; &lt;&lt;&gt;&gt; DiG 9.16.16 &lt;&lt;&gt;&gt; mysql;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 3033;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0;; QUESTION SECTION:;mysql. IN A;; ANSWER SECTION:mysql. 600 IN A 172.18.0.2;; Query time: 0 msec;; SERVER: 127.0.0.11#53(127.0.0.11);; WHEN: Tue Jul 20 04:42:44 UTC 2021;; MSG SIZE rcvd: 44 在“ANSWER SECTION”中，你将看到解析为的A记录（你的 IP 地址很可能具有不同的值）。虽然通常不是有效的主机名，但Docker能够将其解析为具有该网络别名的容器的 IP 地址（还记得我们之前使用的标志吗？）。 这意味着……我们的应用程序只需要连接到一个名为的主机mysql，它就会与数据库对话！ 使用 MySQL 运行我们的应用程序todo 应用程序支持设置一些环境变量来指定 MySQL 连接设置。他们是： MYSQL_HOST - 正在运行的 MySQL 服务器的主机名 MYSQL_USER - 用于连接的用户名 MYSQL_PASSWORD - 用于连接的密码 MYSQL_DB - 连接后使用的数据库 警告 虽然使用 env vars 来设置连接设置对于开发来说通常是可以的，但在生产中运行应用程序时，这是非常不推荐的。Docker 前安全主管 Diogo Monica写了一篇博客文章解释了原因。 更安全的机制是使用你的容器编排框架提供的秘密支持。在大多数情况下，这些机密作为文件安装在正在运行的容器中。你会看到许多应用程序（包括 MySQL 映像和 todo 应用程序）也支持 env vars，_FILE后缀指向包含该变量的文件。 例如，设置MYSQL_PASSWORD_FILEvar 将导致应用程序使用引用文件的内容作为连接密码。Docker 不做任何事情来支持这些环境变量。你的应用程序需要知道查找变量并获取文件内容。 解释完所有这些之后，就可以启动我们开发就绪的容器！ 需要注意： 这里我们使用了$(pwd)这个参数，它是只当前本目录，所以我们应该进入到**本地目录下的app/**目录下，这里我之前没有进入正确的目录下，导致容器一直启动失败。 我们将指定上面的每个环境变量，并将容器连接到我们的应用程序网络。 123456789docker run -dp 8888:3000 \\ -w /app -v &quot;$(pwd):/app&quot; \\ --network todo-app \\ -e MYSQL_HOST=mysql \\ -e MYSQL_USER=root \\ -e MYSQL_PASSWORD=secret \\ -e MYSQL_DB=todos \\ node:12-alpine \\ sh -c &quot;yarn install &amp;&amp; yarn run dev&quot; 我这里使用 bash 报错了，所以我后面使用 PowerShell 后就成功了 如果你使用的是 PowerShell，请使用此命令。 123456789docker run -dp 8888:3000 ` -w /app -v &quot;$(pwd):/app&quot; ` --network todo-app ` -e MYSQL_HOST=mysql ` -e MYSQL_USER=root ` -e MYSQL_PASSWORD=secret ` -e MYSQL_DB=todos ` node:12-alpine ` sh -c &quot;yarn install &amp;&amp; yarn run dev&quot; 启动之后，会返回一个container ID，我们来检测下情况 12345// 查看容器状态是否在运行docker ps -a// 我的结果CONTAINER ID IMAGE CREATED STATUS PORTS e3dd1fe96684 node:12-alpine 3 minutes ago Up 3 minutes 0.0.0.0:8888-&gt;3000/tcp, :::8888-&gt;3000/tcp 如果我们查看容器 ( docker logs &lt;container-id&gt;)的日志，我们应该会看到一条消息，表明它正在使用 mysql 数据库。 12345678# Previous log messages omitted$ nodemon src/index.js[nodemon] 1.19.2[nodemon] to restart at any time, enter `rs`[nodemon] watching dir(s): *.*[nodemon] starting `node src/index.js`Connected to mysql db at host mysqlListening on port 8888 在浏览器中输入：http://localhost:8888/打开该应用程序，并输入一些字符串添加到你的待办事项列表中。 需要注意的是，要用英文、数字，不能使用中文字符。（如果要使用，可以研究下数据库代码来进行配置哦 :wink: ） 连接mysql数据库，证明项目正在写入数据库。请记住，密码是secret。 1docker exec -it &lt;mysql-container-id&gt; mysql -p todos 在 mysql shell 中，运行以下命令： 12345678910mysql&gt; select * from todo_items;+--------------------------------------+---------+-----------+| id | name | completed |+--------------------------------------+---------+-----------+| 444454fc-709f-4088-8fb6-d6a965ef4cef | ffff | 0 || ca7cb357-9c5c-4c8c-8020-1c6e1c56fb4c | check | 0 || 3ced0027-dd54-4c27-845a-3ad3e238d86e | home | 0 || 4775a3aa-86fa-470e-a719-9a583802ff4e | go work | 0 || cbb728b5-f23a-4af0-8d8d-f26271383685 | go home | 0 |+--------------------------------------+---------+-----------+ 可能每个人的数据表看起来会有所不同。 如果你快速查看 Docker 仪表板，你会看到我们有两个应用程序容器正在运行。但是，没有真正的迹象表明它们被组合在一个应用程序中。 Docker Compose安装Windows 如果已经安装了Docker Desktop，那么就不用再安装了 Linux 运行此命令以下载 Docker Compose 的当前稳定版本： 1sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose 要安装不同版本的 Compose，请替换1.29.2 为你要使用的 Compose 版本。 如果你在安装时遇到问题curl，请参阅 上面的替代安装选项选项卡。 对二进制文件应用可执行权限： 1sudo chmod +x /usr/local/bin/docker-compose 注意：如果docker-compose安装后命令失败，请检查你的路径。你还可以/usr/bin在路径中创建指向或任何其他目录的符号链接。 配置、使用请记住，这是我们用来定义应用程序容器的命令。 123456789docker run -dp 8888:3000 \\ -w /app -v &quot;$(pwd):/app&quot; \\ --network todo-app \\ -e MYSQL_HOST=mysql \\ -e MYSQL_USER=root \\ -e MYSQL_PASSWORD=secret \\ -e MYSQL_DB=todos \\ node:12-alpine \\ sh -c &quot;yarn install &amp;&amp; yarn run dev&quot; 如果你使用的是 PowerShell，请使用此命令。 123456789docker run -dp 8888:3000 ` -w /app -v &quot;$(pwd):/app&quot; ` --network todo-app ` -e MYSQL_HOST=mysql ` -e MYSQL_USER=root ` -e MYSQL_PASSWORD=secret ` -e MYSQL_DB=todos ` node:12-alpine ` sh -c &quot;yarn install &amp;&amp; yarn run dev&quot; 首先，让我们为容器定义服务条目和图像。我们可以为服务选择任何名称。该名称将自动成为网络别名，这在定义我们的 MySQL 服务时会很有用。 12345version: &quot;3.8&quot;services: app: image: node:12-alpine 通常，你会在image定义附近看到命令，尽管对排序没有要求。所以，让我们继续把它移到我们的文件中。 123456version: &quot;3.8&quot;services: app: image: node:12-alpine command: sh -c &quot;yarn install &amp;&amp; yarn run dev&quot; 让我们-p 8888:3000通过ports为服务定义来迁移命令的一部分。我们将在这里使用短语法，但也有更详细的长语法可用。 12345678version: &quot;3.8&quot;services: app: image: node:12-alpine command: sh -c &quot;yarn install &amp;&amp; yarn run dev&quot; ports: - 8888:3000 接下来，我们将使用和定义迁移工作目录 ( -w /app) 和卷映射 ( -v &quot;$(pwd):/app&quot;) 。Volumes 也有短句和长句。working_dir``volumes Docker Compose 卷定义的优点之一是我们可以使用当前目录的相对路径。 1234567891011version: &quot;3.8&quot;services: app: image: node:12-alpine command: sh -c &quot;yarn install &amp;&amp; yarn run dev&quot; ports: - 8888:3000 working_dir: /app volumes: - ./:/app 最后，我们需要使用environment密钥迁移环境变量定义。 12345678910111213141516version: &quot;3.8&quot;services: app: image: node:12-alpine command: sh -c &quot;yarn install &amp;&amp; yarn run dev&quot; ports: - 8888:3000 working_dir: /app volumes: - ./:/app environment: MYSQL_HOST: mysql MYSQL_USER: root MYSQL_PASSWORD: secret MYSQL_DB: todos 定义 MySQL 服务现在，是时候定义 MySQL 服务了。我们用于该容器的命令如下： 123456docker run -d \\ --network todo-app --network-alias mysql \\ -v todo-mysql-data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=secret \\ -e MYSQL_DATABASE=todos \\ mysql:5.7 如果你使用的是 PowerShell，请使用此命令。 123456docker run -d ` --network todo-app --network-alias mysql ` -v todo-mysql-data:/var/lib/mysql ` -e MYSQL_ROOT_PASSWORD=secret ` -e MYSQL_DATABASE=todos ` mysql:5.7 我们将首先定义新服务并为其命名，mysql以便它自动获取网络别名。我们将继续并指定要使用的图像。 1234567version: &quot;3.8&quot;services: app: # The app service definition mysql: image: mysql:5.7 接下来，我们将定义卷映射。当我们使用 运行容器时docker run，会自动创建命名卷。但是，使用 Compose 运行时不会发生这种情况。我们需要在顶级volumes:部分定义卷，然后在服务配置中指定挂载点。通过仅提供卷名，使用默认选项。不过，还有更多可用选项。 123456789101112version: &quot;3.8&quot;services: app: # The app service definition mysql: image: mysql:5.7 volumes: - todo-mysql-data:/var/lib/mysqlvolumes: todo-mysql-data: 最后，我们只需要指定环境变量。 123456789101112131415version: &quot;3.8&quot;services: app: # The app service definition mysql: image: mysql:5.7 volumes: - todo-mysql-data:/var/lib/mysql environment: MYSQL_ROOT_PASSWORD: secret MYSQL_DATABASE: todosvolumes: todo-mysql-data: 此时，我们的完整docker-compose.yml应该是这样的： 123456789101112131415161718192021222324252627version: &quot;3.8&quot;services: app: image: node:12-alpine command: sh -c &quot;yarn install &amp;&amp; yarn run dev&quot; ports: - 8888:3000 working_dir: /app volumes: - ./:/app environment: MYSQL_HOST: mysql MYSQL_USER: root MYSQL_PASSWORD: secret MYSQL_DB: todos mysql: image: mysql:5.7 volumes: - todo-mysql-data:/var/lib/mysql environment: MYSQL_ROOT_PASSWORD: secret MYSQL_DATABASE: todosvolumes: todo-mysql-data: 运行我们的应用程序堆栈现在我们有了我们的docker-compose.yml文件，我们可以启动它了！ 确保没有其他 app/db 副本首先运行（docker ps和docker rm -f &lt;ids&gt;）。 使用docker-compose up命令启动应用程序堆栈。我们将添加-d标志以在后台运行所有内容。 1docker-compose up -d 当我们运行它时，我们应该看到这样的输出： 1234Creating network &quot;app_default&quot; with the default driverCreating volume &quot;app_todo-mysql-data&quot; with default driverCreating app_app_1 ... doneCreating app_mysql_1 ... done 你会注意到创建了卷以及网络！ 默认情况下，Docker Compose 会自动为应用程序堆栈创建一个网络（这就是我们没有在 compose 文件中定义网络的原因）。 让我们使用docker-compose logs -f命令查看日志。你将看到来自每个服务的日志交错到一个流中。当你想观察与时序相关的问题时，这非常有用。该-f标志“跟随”的日志，因为它产生这样会给你现场输出。 如果你还没有，你会看到看起来像这样的输出…… 1234mysql_1 | 2019-10-03T03:07:16.083639Z 0 [Note] mysqld: ready for connections.mysql_1 | Version: '5.7.27' socket: '/var/run/mysqld/mysqld.sock' port: 3306 MySQL Community Server (GPL)app_1 | Connected to mysql db at host mysqlapp_1 | Listening on port 8 服务名称显示在行首（通常是彩色的）以帮助区分消息。如果要查看特定服务的日志，可以在logs 命令的末尾添加服务名称（例如，docker-compose logs -f app）。 专业提示 - 在启动应用程序之前等待数据库 当应用程序启动时，它实际上会等待 MySQL 启动并准备好，然后再尝试连接到它。Docker 没有任何内置支持在启动另一个容器之前等待另一个容器完全启动、运行和准备就绪。对于基于 Node 的项目，你可以使用等待端口依赖项。其他语言/框架也存在类似的项目。 此时，你应该能够打开你的应用程序并看到它正在运行。嘿！我们只需要一个命令！ 拆除我们的应用堆栈1docker-compose down 然后就会看到 12345678910$ docker-compose downStopping app_app_1 ...Stopping app_mysql_1 ...Stopping app_app_1 ... doneStopping app_mysql_1 ... doneRemoving app_app_1 ...Removing app_mysql_1 ...Removing app_mysql_1 ... doneRemoving app_app_1 ... doneRemoving network app_default 容器将停止，网络将被移除。默认情况下，运行docker-compose down. 如果要删除卷，则需要添加--volumes标志。 拆除后，你可以切换到另一个项目，运行docker-compose up开始新的项目。 在 Docker 仪表板中查看我们的应用程序堆栈如果我们查看 Docker 仪表板，我们会看到有一个名为app的组。这是来自 Docker Compose 的“项目名称”，用于将容器组合在一起。默认情况下，项目名称只是所在目录的名称docker-compose.yml。 如果你向下旋转应用程序，你将看到我们在撰写文件中定义的两个容器。这些名称也更具描述性，因为它们遵循&lt;project-name&gt;_&lt;service-name&gt;_&lt;replica-number&gt;. 因此，很容易快速查看哪个容器是我们的应用程序，哪个容器是 mysql 数据库。 参考资料Docker-getting-started-tutorial","link":"/Docker-multi-app/"},{"title":"Markdown备忘录","text":"总览该Markdown备忘单是来自Markdown中文网，如果想要了解更多详情，请查看Markdown中文网。 基本语法 元素 Markdown语法 标题 # h1 ## h2### h3 粗体 **bold text** 斜体 *italicaized text* 块引用 &gt; blockquote 有序列表 1. First item2. Second item3. Third item 无序列表 - First item- Second item- Third item 代码 `` 水平线 — 超链接 [ title ](https://www.example.com) 图片 ![ alt text ](image .jpg) 更多详情 -&gt; Markdown基本语法 扩展语法 更多详情 -&gt; Markdown扩展语法","link":"/Markdown-memo/"},{"title":"electron + Vue 初体验","text":"针对Windows设备，使用electron有两种方法，一种是直接安装electron-quick-start，另一种是在Vue的脚手架中安装electron和electron-packager来实现目的。这里使用的是后者，因人而异。 准备Node和Vue的安装可以参考这篇文章npm的安装教程 文章介绍的已经很详细了 初始化npm init webpack electron-vue cd electron-vue 配置 打开config/index.js，设置build下的 assetsPublicPath为./ 进入dist目录 新建index.js文件，设置内容 const {app, BrowserWindow} =require('electron');//引入electron let win; let windowConfig = { width:800, height:600 };//窗口配置程序运行窗口的大小 function createWindow(){ win = new BrowserWindow(windowConfig);//创建一个窗口 win.loadURL(`file://${__dirname}/index.html`);//在窗口内要展示的内容index.html 就是打包生成的index.html //win.webContents.openDevTools(); //开启调试工具，我把它注释了，就不开启 win.on('close',() =&gt; { //回收BrowserWindow对象 win = null; }); win.on('resize',() =&gt; { win.reload(); }) } app.on('ready',createWindow); app.on('window-all-closed',() =&gt; { app.quit(); }); app.on('activate',() =&gt; { if(win == null){ createWindow(); } }); 新建package.json文件，设置内容 { &quot;name&quot;: &quot;demo&quot;, &quot;productName&quot;: &quot;demo&quot;, &quot;author&quot;: &quot;adyo&quot;, &quot;version&quot;: &quot;1.0.4&quot;, &quot;main&quot;: &quot;main.js&quot;, &quot;description&quot;: &quot;demo&quot;, &quot;scripts&quot;: { //自定义指令，感兴趣的可以搜索一下指令 &quot;pack&quot;: &quot;electron-packager . --arch=x64 --overwrite&quot; }, &quot;build&quot;: { &quot;electronVersion&quot;: &quot;1.8.4&quot;, &quot;win&quot;: { &quot;requestedExecutionLevel&quot;: &quot;highestAvailable&quot;, &quot;target&quot;: [ { &quot;target&quot;: &quot;nsis&quot;, &quot;arch&quot;: [ &quot;x64&quot; ] } ] }, &quot;appId&quot;: &quot;demo&quot;, &quot;artifactName&quot;: &quot;demo-${version}-${arch}.${ext}&quot;, &quot;nsis&quot;: { &quot;artifactName&quot;: &quot;demo-${version}-${arch}.${ext}&quot; } }, &quot;dependencies&quot;: { // 手动添加的依赖 &quot;electron&quot;: &quot;^8.2.0&quot;, &quot;electron-packager&quot;: &quot;^12.2.0&quot; } } 在dist目录下执行npm install electron、npm install electron-packager，注意，不添加其他参数，这样是在dist目录下产生了包文件，把dist目录当作打包工作目录，也是可以在Vue的根目录下配置的：看这里，这里面需要注意的是，这里面用到的main.js，可以使用我提供的main.js。 使用 执行npm run build 进入dist目录，执行electron .，能看到桌面应用 在dist目录，执行自己刚才定义的指令npm run pack，就会在本目录下生成一个打包文件，里面有可执行文件 ，至此就有能在桌面使用的js应用了。 参考资料 Vue项目打包桌面应用 手把手教Electron+vue的使用","link":"/Vue&electron-first-exp/"},{"title":"如何更好地使用hexo发布博客","text":"为了方便在Hexo自己撰写并且发布博客，将自己的一些技巧和配置分享一下 设置模板一般我们总是会被写一篇文章还要配置hexo文章的头部（包括时间、标签、分类等）烦的要死，而且有的hexo主题没有给文章查看更多的总配置，更加增加了撰写的复杂度。 所以我们要用到scaffolds下的post.md文件，它是我们发布文章的时候默认使用的模板，以下是我配置内容。 123456789101112---title: {{ title }}date: {{ date }}toc: truecategories:excerpt: 显示在文章缩略图的 文字tags:---这里填写 显示在文章缩略图的 文字&lt;!-- more --&gt;这里填写 更多文章内容 巧用 命令一般我们发布文章： 1hexo new post &quot;file-name&quot; 我们会为了文章的url中不包含汉字，会用我们贫瘠的英语绞尽脑汁地想出几个英文名称，然后引来”嘲笑“，我们自己也会觉得难看。 但是，福音来了！，只需要一个简单的参数-s就可以解决，如下： 1hexo new post &quot;我的中文标题&quot; -s &quot;my-url-title&quot; 这样配置之后，浏览器目录path显示的就是后者了。 巧用GitHub最初，编写Markdown发布博客文章都是将Hexo部署到云服务器上，然后开启Web网络服务来进行使用。但是随着大学毕业，“学生机”已经无法继续续费使用了，因此，就想到了GitHub还有个博客功能。 发布思路： 12345本地机器 ----------&gt; Hexo --------&gt; 远程GitHub.io | | | | | | | | |撰写文章 配置部署功能 浏览器浏览访问 配置Hexo找到Hexo的主配置文件_config.yml的deploy字段，比如我的配置文件： 1234deploy: type: git repo: &lt; 自己的git的博客地址 &gt; branch: master 如果没有Git博客，需要先去GitHub上申请一个 还要配置一下post_asset_folder参数，保证我们能把图片资源上传到git 1post_asset_folder: true 发布部署 1234// 生成html等资源hexo g # hexo generate// 部署到远程hexo d # hexo deploy 也许会让你输入git账号密码，可能是因为我之前有git化这个文件，所以没有输入账号密码。 之后就能够在相应的Git上查看自己的博客了！我的博客为 =&gt; 这里","link":"/better-use-hexo/"},{"title":"如何配置多个ssh的id_rsa","text":"相信大多数开发人员用ssh免密登录会遇到这样的情况： 用ssh本地登录自己的远程服务器 用ssh本地配置自己的GitHub账号 但是，默认生成的id_rsa文件是首选，要怎么才能够让各个不同的应用场景对应各个不同的id_rsa呢？ 由于以前胡乱配置过一些相关信息，可能你们有的问题我没出现，但是问题不大，把报错内容查一下可以解决的 生成ssh公钥和私钥1234567891011cd ~# 查看是否有.ssh文件，它属于隐藏文件# Windows下如果想在文件管理器下查看，需要设置可见隐藏文件ll -a# 如果有直接进入cd .ssh# 如果没有，会自动生成# 但是执行这个，相当于指定认证了本机，一般适用于登录自己的服务器ssh-keygen -t rsa# 认证绑定GitHub用户邮箱，一般适用于GitHubssh-keygen -t rsa -C &quot;example@example.com&quot; 1234ssh-keygen -t rsa# 它会提示以下内容，如果是第一次生成，三次enter就可以了，默认名字为id_rsa# 如果有能力和兴趣，可以了解搜下它分别提示的内容Enter file in which to save the key (/c/Users/Administrator/.ssh/id_rsa): 123# 但是如果你又要生成GitHub的，它可能会覆盖原有的id_rsa，所以要自己设置下名称github_id_rsassh-keygen -t rsa -C &quot;example@example.com&quot;Enter file in which to save the key (/c/Users/Administrator/.ssh/id_rsa): github_id_rsa 之后会生成两组密钥，四个文件：id_rsa、 id_rsa.pub、 github_id_rsa、 github_id_rsa.pub .pub文件是公钥，是要发给服务器的，另一个是私钥，是要自己保存的 Git配置时出现Could not open a connection to your authentication agent先执行如下命令 1ssh-add ~/.ssh/github_id_rsa 如果依然报错，则执行下面的命令 123eval `ssh-agent` #（是～键上的那个` 反引号） ssh-add ~/.ssh/github_id_Rsassh-add -l 或者 123ssh-agent bash ssh-add ~/.ssh/github_id_Rsassh-add -l 配置服务器GitHub【点击头像】=&gt;【Settings】=&gt;【SSH and GPG keys】=&gt;【New SSH key】 Title随便命名一个自己能够区别的名称 Key内容是相应的公钥内容，也就是github_id_rsa.pub内容 Linux服务器12345678cd .ssh# 如果没有ssh localhost# 查看是否又authorized_keys文件ls# 如果没有touch authorized_keys# 然后将本地的 id_rsa.pub 复制到里面 设置本地.ssh文件1touch config 填写转发内容，其中 IdentityFile 需要是绝对路径，相对路径会报错 123456789Host 39.108.179.50 # 别名，不重要HostName 39.108.179.50 # 对应网站的url，重要！User rootIdentityFile ~/.ssh/id_rsaHost github.com # 别名，不重要HostName github.com # 对应网站的url，重要！User WYDgitsIdentityFile ~/.ssh/github_id_rsa 验证123456ssh -T git@github.com# ssh -Tv git@github.com 来debug# 提示信息# Hi &lt;yourname&gt;! You've successfully authenticated, but GitHub does not provide shell access.ssh root@39.108.179.50# 成功的话能够直接登录进去服务器的bash 参考是否必须每次添加ssh-add Git配置时出现Could not open a connection to your authentication agent","link":"/configMulssh/"},{"title":"解决Hexo引入图片时的路径错误","text":"问题 hexo在文章中引入图片有两种方法 前提：修改_config.yml配置文件中的post_asset_folder项为true。是为了在创建博客的时候，同时创建一个同名文件夹 不使用插件： {% asset_img 这是一个新的博客的图片.jpg 这是一个新的博客的图片的说明 %} 使用插件： npm install hexo-asset-image --save 但是！插件好像有bug，我的图片路径一直时错误的，而显示不出来！ 解决 打开/node_modules/hexo-asset-image/index.js，将内容更换为下面的代码 'use strict'; var cheerio = require('cheerio'); // http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string function getPosition(str, m, i) { return str.split(m, i).join(m).length; } var version = String(hexo.version).split('.'); hexo.extend.filter.register('after_post_render', function(data){ var config = hexo.config; if(config.post_asset_folder){ var link = data.permalink; if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, '/', 1) + 1; else var beginPos = getPosition(link, '/', 3) + 1; // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;. var endPos = link.lastIndexOf('/') + 1; link = link.substring(beginPos, endPos); var toprocess = ['excerpt', 'more', 'content']; for(var i = 0; i &lt; toprocess.length; i++){ var key = toprocess[i]; var $ = cheerio.load(data[key], { ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false }); $('img').each(function(){ if ($(this).attr('src')){ // For windows style path, we replace '\\' to '/'. var src = $(this).attr('src').replace('\\\\', '/'); if(!/http[s]*.*|\\/\\/.*/.test(src) &amp;&amp; !/^\\s*\\//.test(src)) { // For &quot;about&quot; page, the first part of &quot;src&quot; can't be removed. // In addition, to support multi-level local directory. var linkArray = link.split('/').filter(function(elem){ return elem != ''; }); var srcArray = src.split('/').filter(function(elem){ return elem != '' &amp;&amp; elem != '.'; }); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join('/'); $(this).attr('src', config.root + link + src); console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src); } }else{ console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;); console.info&amp;&amp;console.info($(this)); } }); data[key] = $.html(); } } }); 最好重启下，因为我执行hexo g之后没有立即改变，之后就可以正常显示图片了 参考资料 Hexo发布博客引用自带图片的方法hexo引用本地图片无法显示","link":"/five/"},{"title":"Flex布局解析","text":"Flex布局是什么Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为Flex布局 .box{ display: flex; } 行内元素也可以使用Flex布局 .box{ display:inline-flex } Webkit内核的浏览器，必须加上-webkit前缀 .box{ display:-webkit-flex;/* Safari */ display:flex; } 注意⚠️，设为Flex布局之后，子元素的float、clear和vertical-align属性将失效 基本概念采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis） 项目默认沿主轴排列； 主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end； 交叉轴的开始位置叫做cross start，结束位置叫做cross end； 单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 容器的属性以下6个属性设置在容器上 flex-direction、flex-wrap、flex-flow、justify-content、align-items、align-content flex-direction属性flex-direction属性决定主轴的方向（即项目的排列方向）。 .box { flex-direction: row | row-reverse | column | column-reverse; } 它可能有4个值 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap属性默认情况下，项目都排在一条线(又称“轴线”)上。flex-wrap属性定义，如果一条轴线排不下，如何换行 .box{ flex-wrap: nowrap | wrap | wrap-reverse; } 它可能取三个值 nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 flex-flow属性flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 .box { flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; } justify-content属性justify-content属性定义了项目在主轴上的对齐方式。 .box { justify-content: flex-start | flex-end | center | space-between | space-around; } 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items属性align-items属性定义项目在交叉轴上如何对齐。 .box { align-items: flex-start | flex-end | center | baseline | stretch; } 它可能取5个值，具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 .box { align-content: flex-start | flex-end | center | space-between | space-around | stretch; } 它可能取6个值。 lex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 项目的属性以下6个属性设置在项目上 order、flex-grow、flex-shrink、flex-basis、flex、align-self order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 .item { order: &lt;integer&gt;; } flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 .item { flex-grow: &lt;number&gt;; /* default 0 */ } 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话)。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 .item { flex-shrink: &lt;number&gt;; /* default 1 */ } 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 .item { flex-basis: &lt;length&gt; | auto; /* default auto */ } 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 flex属性flex属性是flex-grow, flex-shrink和flex-basis的简写，默认值为flex : 0 1 auto。后两个属性可选。 .item { flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ] } 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 .item { align-self: auto | flex-start | flex-end | center | baseline | stretch; } 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 参考资料 Flex布局入门 Flex 布局教程：语法篇","link":"/flex-layout/"},{"title":"Windows配置nvm所遇到的一些问题","text":"之前一直单独用的node ，对于node的版本也不敏感，然后组长说之后项目会需要不同的node版本，就让我们去了解安装一下nvm。今天第一次接触到nvm这个工具，就先下载了，虽然也提示了：可能会删掉部分原先node的配置，但我没放心上，结果有的node安装的命令找不到了，然后花了大量时间才算是了解、配置成功。 什么是nvm nvm is a version manager for node.js, designed to be installed per-user, and invoked per-shell. nvm works on any POSIX-compliant shell (sh, dash, ksh, zsh, bash), in particular on these platforms: unix, macOS, and windows WSL. 简单点说：nvm是一个node的版本管理工具。 因为node有很多版本嘛，所以这个工具就是用来下载、安装和管理node的各个版本 准备如果曾经安装过node，需要先删除卸载掉node，从控制面板 =&gt; 卸载 =&gt; 找到node，卸载。 如果没有安装过，可以忽略这一步。 下载安装命令下载 本人未使用这种方式，谨慎使用🙃，Windows的话直接官网下载比较好 1234# 1. curl方式curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh | bash# 2. wget方式wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh | bash 官网下载地址在这里，直接下载安装nvm for Windows nvm-noinstall.zip：绿色免安装版，但使用时需进行配置。 nvm-setup.zip：安装版，推荐使用 安装配置npm配置下载成功之后，会有两个步骤，这里不贴图片了。 选择安装nvm的目录： 建议放到d:\\nvm\\nvm\\ 选择安装node的目录 建议放到d:\\nvm\\nodejs\\ 之所以这样配置，是方便管理和使用，其他目录也是可以的。 注意：安装完成之后，这个nodejs文件夹是还没有创建的，因为还没有安装node 进入d:\\nvm\\nvm\\，打开settings.txt添加这两行内容，分别是node和npm的下载源 12node_mirror: https://npm.taobao.org/mirrors/node/npm_mirror: https://npm.taobao.org/mirrors/npm/ 然后下载npm的某一版本，可以参考以下命令 12nvm install 12.22.3 # 下载安装 12.22.3版本的node，并且会把对应版本的npm也下载好nvm use 12.22.3 # 本地环境切换到 12.22.3 版本的node 这个时候，d:\\nvm\\nodejs\\就创建成功了，然后在里面创建node_global和node_cache两个文件夹，它们分别用来保存npm全局安装包和缓存的。 文件名称千万别拼写错了！ 然后执行下面两条命令来修改npm全局安装包和缓存的位置： 123npm config set prefix=&quot;D:\\nvm\\nvm\\nodejs\\node_global&quot;npm config set cache=&quot;D:\\nvm\\nvm\\nodejs\\node_cache&quot; 这里需要用引号包裹住，否则会出现目录问题，可以用以下命令检测一下 ，看看目录是否有一致 123npm config get prefixnpm config get cache 这时候使用npm安装的全局包都会安装到指定的路径，可以在命令行工具执行npm i express -g，然后去D:\\nvm\\nodejs\\node_global\\node_modules目录查看是否有相应的文件。如果没有，需要再检查下前面设置的目录是否出错。 配置好后在C:\\Users\\administrator下会出现.npmrc这个文件，说明配置成功。 这个时候，我们使用npm全局安装包的时候，就已经能够安装到我们指定的目录下，但是我们还没有办法使用安装好的全局命令。 环境变量配置一般环境变量在你安装的时候就已经配置好了，可以检查一下，如果没有，需要自己配置进去。 用户变量 变量 值 备注 NVM_HOME D:\\nvm\\nvm NVM_SYMLINK D:\\nvm\\nodejs NODE_PATH D:\\nvm\\nodejs\\node_global\\node_modules 系统变量 变量 值 备注 Path %NVM_HOME% %NVM_SYMLINK% D:\\nvm\\nodejs\\node_global NODE_PATH 和 Path 中 node相关路径的区分 操作系统中都会有一个Path （它是不区分大小写）环境变量，当系统调用一个命令的时候，就会在Path变量中注册的路径中寻找，如果注册的路径中有就调用，否则就提示命令没找到。 这也就是为什么有时候我们安装好了相关包文件，但是使用不了相应的命令：xxx not found 那 NODE_PATH 就是node中用来寻找模块所提供的路径注册环境变量。 比如一些常用的模块文件 简单来说，PATH用来找命令，NODE_PATH用来找模块。 node安装的相应的全局命令，要么在对应文件的bin下，要么在node_global目录下，所以我们选择后者，一次配置就可以了😁。 而相应的全局文件，则是在node_global/node_modules下，所以这两者略有差异。 终于把它们区分清楚了！ 其他注意事项 使用nvm管理版本的时候，各个npm版本的包文件是不相通的，也就是说12.x版本的npm用不了11.x版本的包文件，虽然有点麻烦，但是也比较合理，毕竟各个版本用途可能会有变动。 参考资料nvm安装以及node配置 安装node.js和Hexo","link":"/config-nvm/"},{"title":"计算机网络基础知识","text":"典型的数据通信模型 如果两个计算机是通过交换机进行通信的，直接用数字比特流进行通信。 相关术语 信道 单工通信：例如电视和电视台，你可以接受电视台的信号，但是无法向电视台发送信号。 半双工通信：例如常用的对讲机。 全双工通信：例如我们的手机、电话通信。 基带信号、带通信号 基本的信号调制方法 常见编码 曼彻斯特编码 差分曼彻斯特编码 对比","link":"/four/"},{"title":"Hello Hexo","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","link":"/hello-hexo/"},{"title":"防盗链？","text":"说是有用，但是为什么加上meta标签配置之后，就有能够访问显示了呢？ 防盗链是什么？首先代入一下情景： 如果你刚刚开发完一个没有防盗链的带有文件下载功能的网站，挂上internet，然后上传几个时下非常热门的软件或电影并在网站内公布下载地址，让MSN上的所有好友都来体验一下你的杰作。不用多久就会发现网速出奇地变慢，甚至服务器托管中心的服务员会热情地打电话告诉你的网站流量很大，估计是网站受欢迎起来了，问你是不是该考虑加钱租用带宽更宽但价格更贵的网线了。 在这个值得庆祝的时候赶快打开Google Analytics看看有多少人来光顾你的网站了吧，如果发现访客每天才十来个人，很遗憾地告诉你：你的网站资源不幸地被人盗链了。而且更糟糕的是，当你把网站上的文件和电影通通删光之后，网站仍然没有变快多少，从web服务器的访问日志里会发现疯狂的访问请求正从四面八方涌过来，web服务器为了迎接这批访客而没有时间处理正常的页面，这种状况可能会一直持续好几个周时间。 或者另一种场景： 公司开发一个富文本功能，你使用了wangEditor这个插件来使用，但是后来发现里面的一个功能：插入网络图片，会出现一些bug，有的网络图片能够成功插入，而有的网络图片却没办法插入，并且报错403被拒绝访问了？然后网上发现只需要一行代码就能够让403的图片成功插入，这又是为啥？ 123&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;&lt;!-- 或者 --&gt;&lt;img src=&quot;xxxx.jpg&quot; referrerPolicy=&quot;no-referrer&quot; /&gt; HTTP首部：referrerHTTP Referer是header的一部分，当浏览器向web服务器发出请求的时候，一般会带上Referer,告诉服务器用户从那个页面连接过来的。 可以判断网站来源,相应的做一些校验,比如只允许某网站的请求,那么就可以通过获取referer,加以判断即可. 注意：是这个请求是哪个页面发出的,referer就是哪个页面 想要了解更多，可以参考： referrer策略和meta标签的问题 HTTP首部—referrer 知识点 如何避免和使用使用加了防盗链的资源123&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;&lt;!-- 或者 --&gt;&lt;img src=&quot;xxxx.jpg&quot; referrerPolicy=&quot;no-referrer&quot; /&gt; 在相应的html文件上加上以上代码，就可以获取到加了防盗链的资源，原因是： 本页面内通过发起的http请求都不会加上referrer这个属性，对方也就判断不了是不是来自其他网站的请求，就能够获取到资源了。 但是！！！ 避免被盗基本的就是服务器上面对http请求头的referrer属性的值进行判断，如果不是本网站的url，则拒绝访问…… 之后再补充内容 参考资料八种常见的防盗链方法总结及分析 什么是防盗链","link":"/http-referrer/"},{"title":"随便写写","text":"2020结束了，考研也结束了;2021开始了，毕业设计也开始。 把博客搞了下，换了个好看一点的主题，虽然这么折腾但是依旧很菜...... 等服务器到期了，如果用不上服务器，就把博客迁移到GitHub上面...... 原来markdown上面的某些标签可以添加html的标签，而且还能添加css的一些样式，学到了...... 折腾过程中，也把docker的命令简单复习了一下，发现了docker exec这个命令其实很有用的...... 昨晚上又做梦，梦到考研在考场的时候，这好像是第二次梦到在考场，这总是让我很慌...... 害，希望武汉给我个机会去那里生活几年甚至更久......","link":"/just-so/"},{"title":"linux漏洞修复","text":"前言本内容根据个人经历所记，会解决大部分漏洞内容，但不一定包括全部。 软件漏洞一般的软件漏洞，比如：Git、Python、PHP、MySQL、Vim、curl等大部分漏洞，基本上都可以通过更新软件就可以解决。 我云服务上曾经的软件漏洞200+，几个命令全部解决。 由于本人云服务器系统为 Ubuntu，所以对应的介绍都是Ubuntu的，其他系统的估计也差不太多，只是命令的差异。 12345678910// 查看Ubuntu版本$ cat /etc/issueUbuntu 16.04.7 LTS \\n \\l// 在更新系统中的包时，建议按顺序执行下面的命令：// 重新同步包索引文件$ apt-get update// 安装系统上当前安装的所有包的最新版本 -y 表示默认 yes$ apt-get upgrade -y// 除执行 upgrade 升级功能外，还智能地处理与新版本包的依赖关系的变化$ apt-get dist-upgrade -y 更新期间，可能会花十分钟左右，取决于系统内的软件的数量和大小。 常用参数介绍： 参数 解析 备注 update update 命令用于重新同步包索引文件，/etc/apt/sources.list 文件中的配置指定了包索引文件的来源。更新了包索引文件后就可以得到可用的包的更新信息和新的包信息。这样我们本地就有了这样的信息：有哪些软件的哪些版本可以从什么地方(源)安装。 update 命令应该总是在安装或升级包之前执行。 upgrade upgrade 命令用于从 /etc/apt/sources.list 中列出的源安装系统上当前安装的所有包的最新版本。在任何情况下，当前安装的软件包都不会被删除，尚未安装的软件包也不会被检索和安装。如果当前安装的包的新版本不能在不更改另一个包的安装状态的情况下升级，则将保留当前版本。必须提前执行 update 命令以便 apt-get 知道已安装的包是否有新版本可用。 注意 update 与 upgrade 的区别：update 是更新软件列表，upgrade 是更新软件。 dist-upgrade 除执行升级功能外，dist-upgrade 还智能地处理与新版本包的依赖关系的变化。apt-get 有一个 “智能” 的冲突解决系统，如果有必要，它将尝试升级最重要的包，以牺牲不那么重要的包为代价。 dist-upgrade 命令可能会删除一些包。 install install 命令用来安装或者升级包。每个包都有一个包名，而不是一个完全限定的文件名(例如，在 Debian 系统中，提供的参数是 apt-utils，而不是 apt-utils_1.6.1_amd64.deb)。被安装的包依赖的包也将被安装。配置文件 /etc/apt/sources.list 中包含了用于获取包的源(服务器)。 install 命令还可以用来更新指定的包。 更多参数请了解 apt-get(8) - Linux man page Ubuntu : apt-get 命令 系统漏洞我更新完全部软件之后，只剩下系统相关的漏洞了，然后把服务器的全部服务先关闭，然后重启(也可以直接重启)。之后对剩下的系统相关的漏洞也进行了验证，奇怪的是，这些漏洞也都相应的修复了！😂","link":"/linux-soft-bug-repair/"},{"title":"计算机图形学作业","text":"第六章作业 6-1 请使用OpenGL、GLU和GLUT编写一个显示线框立方体的程序。其中立方体的半径为1.5单位，并首先绕(0, 0, 0)~(1, 1, 0)旋转30度，然后远移6.5单位；观察体规定为：视场角=30度，宽高比=1，近=1，远=100；程序窗口的大小为(200, 200)，标题为“线框立方体”。 #include &lt;gl/glut.h&gt; void init() { glutInitDisplayMode(GLUT_SINGLE|GLUT_RGBA); glutInitWindowSize(200,200); glutCreateWindow(&quot;线框立方体&quot;); } void Paint() { glClear(GL_COLOR_BUFFER_BIT); glLoadIdentity(); gluPerspective(30, 1, 1, 100); glTranslated(0, 0, -6.5); glRotated(30, 1, 1, 0); glutWireCube(1.5); glFlush(); } int main(int argc, char *argv[]) { glutInit(&amp;argc, argv); init(); glutDisplayFunc(Paint); glutMainLoop(); } 6-2 请使用OpenGL和GLUT编写一个显示线框球体的简单图形程序。其中球体的半径为0.8，经线数为24，纬线数为12，并绕 x 轴旋转30度，程序窗口的大小为(200, 200)，标题为“线框球”。 #include &lt;gl/glut.h&gt; void init(){ glutInitDisplayMode(GLUT_SINGLE|GLUT_RGBA); glutInitWindowSize(200,200); glutCreateWindow(&quot;线框球&quot;); } void Paint(){ glClear(GL_COLOR_BUFFER_BIT); glLoadIdentity(); glRotated(30, 1, 0, 0); glutWireSphere(0.8,24,12); glFlush(); } int main(int argc, char *argv[]){ glutInit(&amp;argc, argv); init(); glutDisplayFunc(Paint); glutMainLoop(); } 6-3 请使用OpenGL和GLUT编写一个显示线框椭球体的简单图形程序。其中椭球体的两极方向为上下方向，左右方向的半径为0.98，上下方向的半径为0.49，前后方向的半径为0.6，经线数为48，纬线数为24，使用正投影，裁剪窗口为(-1,-0.5)~(1, 0.5)，程序窗口的大小为(400, 200)，标题为“线框椭球”。 #include &lt;gl/glut.h&gt; void init() { glutInitDisplayMode(GLUT_SINGLE|GLUT_RGBA); glutInitWindowSize(400,200); glutCreateWindow(&quot;线框椭球&quot;); } void Paint() { glClear(GL_COLOR_BUFFER_BIT); glLoadIdentity(); gluOrtho2D(-1, 1, -0.5, 0.5); glScaled(9.8,4.9,6); glutWireSphere(0.1,48,25); glFlush(); } int main(int argc, char *argv[]) { glutInit(&amp;argc, argv); init(); glutDisplayFunc(Paint); glutMainLoop(); } 6-4 请使用OpenGL、GLU和GLUT编写一个三维犹他茶壶程序。其中茶壶的半径为1单位，并远移6.5单位；观察体规定为：视场角=30度，宽高比=1，近=1，远=100；程序窗口的大小为(200, 200)，标题为“旋转的尤他茶壶”。茶壶绕z轴不断旋转，旋转的时间间隔为25毫秒，角度间隔为2度。注意旋转角度必须限定在0～360度以内。 #include &lt;gl/glut.h&gt; int angle = 0; void init(){ glutInitDisplayMode(GLUT_SINGLE|GLUT_RGBA); glutInitWindowSize(200,200); glutCreateWindow(&quot;旋转的尤他茶壶&quot;); } void Paint(){ glClear(GL_COLOR_BUFFER_BIT); glLoadIdentity(); gluPerspective(30, 1, 1, 100);//观察体规定 glTranslatef(0, 0, -6.5); //远移6.5单位 glRotated(angle, 0, 0, 1);//绕z轴 glutSolidTeapot(1);//半径为1 glFlush(); } void timer(int millis){ angle = (angle + 2) % 360; //角度间隔2度 glutPostRedisplay(); glutTimerFunc(millis, timer, millis); } int main(int argc, char *argv[]){ glutInit(&amp;argc, argv); init(); glutTimerFunc(25, timer, 25);//时间间隔25ms glutDisplayFunc(Paint); glutMainLoop(); } 6-5 请使用OpenGL、GLU和GLUT编写一个简单的多视口演示程序。要求：在屏幕窗口左下角的1/4部分显示一个红色的填充正三角形；在屏幕窗口右上角的1/4部分显示一个绿色的填充正方形；三角形和正方形的左下角顶点坐标值均为(0,0)，右下角顶点坐标值均为(1, 0)；裁剪窗口均为(-0.1, -0.1)～(1.1, 1.1)；程序窗口的大小为(200, 200)，标题为“多视口演示”。 #include &lt;gl/glut.h&gt; int angle = 0; void init(){ glutInitDisplayMode(GLUT_SINGLE|GLUT_RGBA); glutInitWindowSize(200,200); glutCreateWindow(&quot;多视口演示&quot;); } void Viewport(int x, int y, int w, int h){ glViewport(x, y, w, h); glLoadIdentity(); gluOrtho2D(-0.1, 1.1, -0.1, 1.1); } void Paint(){ int w = glutGet(GLUT_WINDOW_WIDTH) / 2; int h = glutGet(GLUT_WINDOW_HEIGHT) / 2; glClear(GL_COLOR_BUFFER_BIT); Viewport(0, 0, w, h); glColor3f(1, 0, 0); glBegin(GL_TRIANGLES); glVertex2d(0, 0); glVertex2d(1, 0); glVertex2d(0.5, 0.8660); glEnd(); Viewport(w, h, w, h); glColor3f(0, 1, 0); glRectf(0,0,1,1); glFlush(); } int main(int argc, char *argv[]){ glutInit(&amp;argc, argv); init(); glutDisplayFunc(Paint); glutMainLoop(); } 6-6 请使用OpenGL、GLU和GLUT编写一个多视口演示程序。要求：① 在屏幕窗口左下角的1/4部分显示一个红色的填充矩形，该矩形的一对对角顶点是(0, 0)和(1, 1)；② 在屏幕窗口右下角的1/4部分显示一个绿色的填充犹他茶壶，茶壶半径为0.4，并向右向上各移0.5；③ 在屏幕窗口上部居中的1/4部分显示一个蓝色的填充正三角形，该正三角形的左下角顶点是(0, 0)，右下角顶点是(1, 0)；④ 裁剪窗口均为(-0.1, -0.1)～(1.1, 1.1)，程序窗口的大小为(200, 200)，背景为黑色，标题为“多视口演示”。 #include &lt;gl/glut.h&gt; void init(){ glutInitDisplayMode(GLUT_SINGLE|GLUT_RGBA); glutInitWindowSize(200,200); glutCreateWindow(&quot;多视口演示&quot;); } void Viewport(int x, int y, int w, int h){ glViewport(x, y, w, h); glLoadIdentity(); gluOrtho2D(-0.1, 1.1, -0.1, 1.1); } void Paint(){ int w = glutGet(GLUT_WINDOW_WIDTH) / 2; int h = glutGet(GLUT_WINDOW_HEIGHT) / 2; glClear(GL_COLOR_BUFFER_BIT); Viewport(0, 0, w, h);//左下角 glColor3f(1, 0, 0); glRectf(0,0,1,1); Viewport(w, 0, w, h);//右下角 glColor3f(0, 1, 0); glTranslated(0.5,0.5,0); glutSolidTeapot(0.4); Viewport(w/2, h, w, h);//上中部 glColor3f(0, 0, 1); glBegin(GL_TRIANGLES); glVertex2d(0, 0); glVertex2d(1, 0); glVertex2d(0.5, 0.8660); glEnd(); glFlush(); } int main(int argc, char *argv[]){ glutInit(&amp;argc, argv); init(); glutDisplayFunc(Paint); glutMainLoop(); } 第三章作业 请写出OpenGL中指定点的大小和线宽的函数，要求写出完整的函数原型。 void glPointSize(GLfloat size) void glLineWidth(GLfloat width) 请写出OpenGL中启用点、线、面反走样的函数调用。 启动点反走样:glEnable(GL_POINT_SMOOTH) 启动线段反走样:glEnable(GL_LINE_SMOOTH) 启动多边形的反走样:glEnable(GL_POLYGON_SMOOTH) 请使用OpenGL和GLUT编写一个简单的图形程序，用于显示一个填充的白色正方形。其中正方形的左下角顶点是(-0.8, -0.8)，右下角顶点是(0.8, -0.8)，程序窗口的大小为(200, 200)，标题为“白色正方形”。 #include &lt;GL/glut.h&gt; void Paint() // 对象的描述 { glClear(GL_COLOR_BUFFER_BIT); // 清除颜色缓冲区 glRectf(-0.8,-0.8,0.8,0.8); // 定义矩形：正方形是特殊的矩形 glFlush(); } int main(int argc, char *argv[]) { glutInit(&amp;argc, argv); // 初始化GLUT, 记录main()函数的参数 glutInitDisplayMode(GLUT_SINGLE | GLUT_RGBA);// 设置程序窗口的显示模式(单缓存, RGBA颜色模式, 默认值) glutInitWindowSize(200, 200); // 设置程序窗口在屏幕上的大小 glutCreateWindow(&quot;白色正方形&quot;); // 设置窗口的标题 glutDisplayFunc(Paint); // 指定场景绘制循环函数, 必须 glutMainLoop(); // 开始循环执行OpenGL命令 } 运行结果： 请使用OpenGL和GLUT编写一个简单的图形程序，用于显示一个填充的红色正三角形。其中正三角形的左下角顶点是(-0.5, 0)，右下角顶点是(0.5, 0)，程序窗口大小为(200, 200)，标题为“红色正三角形”。 #include &lt;GL/glut.h&gt; void Paint() // 对象的描述 { glClear(GL_COLOR_BUFFER_BIT); // 清除颜色缓冲区 glColor3f(1,0,0);// 定义红色 glBegin(GL_TRIANGLES); // 开始定义三角形 { glVertex2f(-0.5, 0); // 指定二维顶点坐标 glVertex2f(0.5, 0); glVertex2f(0, 0.9); } glEnd(); // 结束三角形的定义 glFlush(); // 强制OpenGL命令序列在有限的时间内完成执行 } int main(int argc, char *argv[]) { glutInit(&amp;argc, argv); // 初始化GLUT, 记录main()函数的参数 glutInitDisplayMode(GLUT_SINGLE | GLUT_RGBA);// 设置程序窗口的显示模式(单缓存, RGBA颜色模式, 默认值) glutInitWindowPosition(100, 100); // 设置程序窗口在屏幕上的位置 glutInitWindowSize(200, 200); // 设置程序窗口在屏幕上的大小 glutCreateWindow(&quot;红色正三角形&quot;); // 设置窗口的标题 glutDisplayFunc(Paint); // 指定场景绘制循环函数, 必须 glutMainLoop(); // 开始循环执行OpenGL命令 } 运行结果： 请使用OpenGL和GLUT编写一个简单的图形程序，用于显示一个填充的蓝色四边形。其中四边形的4个顶点分别是(-0.8, -0.8)、(0.5, -0.8)、(0.8, 0.8)和(-0.5,0.8)，程序窗口的大小为(200, 200)，背景为白色，标题为“蓝色四边形”。 #include &lt;GL/glut.h&gt; void Paint() // 对象的描述 { glClearColor(1, 1, 1, 1);//定义背景颜色为白色 glClear(GL_COLOR_BUFFER_BIT); // 清除颜色缓冲区 glColor3f(0,0,1);// 定义蓝色 glBegin(GL_QUADS);//绘制四边形 { glVertex2f(-0.8,-0.8);//定义顶点 glVertex2f(0.5,-0.8); glVertex2f(0.8,0.8); glVertex2f(-0.5,0.8); } glEnd(); glFlush(); // 强制OpenGL命令序列在有限的时间内完成执行 } int main(int argc, char *argv[]) { glutInit(&amp;argc, argv); // 初始化GLUT, 记录main()函数的参数 glutInitDisplayMode(GLUT_SINGLE | GLUT_RGBA);// 设置程序窗口的显示模式(单缓存, RGBA颜色模式, 默认值) glutInitWindowPosition(100, 100); // 设置程序窗口在屏幕上的位置 glutInitWindowSize(200, 200); // 设置程序窗口在屏幕上的大小 glutCreateWindow(&quot;蓝色四边形&quot;); // 设置窗口的标题 glutDisplayFunc(Paint); // 指定场景绘制循环函数, 必须 glutMainLoop(); // 开始循环执行OpenGL命令 } 运行结果： 请使用OpenGL和GLUT编写一个简单的图形程序，用于演示点的反走样效果。要求使用线段(-0.6, -0.6)～(0.6, 0.6)上均匀分布的5个点（含端点），点的大小为10.5像素，程序窗口的大小为(200, 200)，标题为“点的反走样”。 #include &lt;GL/glut.h&gt; void Paint() { double x; glClear(GL_COLOR_BUFFER_BIT); glBegin(GL_POINTS); for(x = -0.6;x&lt;=0.6;x+=0.3) glVertex2f(x,x); glEnd(); glFlush(); } int main(int argc,char *argv[]) { glutInit(&amp;argc, argv); glutInitWindowSize(200,200); glutCreateWindow(&quot;点的反走样&quot;); glutDisplayFunc(Paint); glPointSize(10.5); glEnable(GL_POINT_SMOOTH); glutMainLoop(); } 运行结果： 请使用OpenGL和GLUT编写一个简单的图形程序，用于演示线段的反走样效果。其中线段的端点为(-0.6, -0.3)和(0.6, 0.3)，线宽为4.5像素，程序窗口的大小为(200, 200)，标题为“线段的反走样”。 #include &lt;GL/glut.h&gt; void Paint() { double x; glClear(GL_COLOR_BUFFER_BIT); glBegin(GL_LINE_STRIP); { glVertex2f(-0.6,-0.3); glVertex2f(0.6,0.3); } glEnd(); glFlush(); } int main(int argc,char *argv[]) { glutInit(&amp;argc, argv); glutInitWindowSize(200,200); glutCreateWindow(&quot;线段的反走样&quot;); glutDisplayFunc(Paint); glLineWidth(4.5); glEnable(GL_LINE_STIPPLE); glutMainLoop(); } 运行结果： 请使用OpenGL、GLU和GLUT编写一个简单的多视口演示程序。要求：① 在屏幕窗口左侧的1/2部分显示一个红色的填充矩形，该矩形的一对对角顶点是(-0.8, -0.8)和(0.8, 0.8)；② 在屏幕窗口右侧的1/2部分显示一个蓝色的填充犹他茶壶，茶壶半径为0.6；③ 程序窗口的大小为(400, 200)，背景为黑色，标题为“多视口演示”。 #include &lt;gl/glut.h&gt; Viewport(int x, int y, int w, int h) { glViewport(x, y, w, h); // 定义视口 glLoadIdentity(); // 消除其他视口的影响, 函数介绍见后续章节 } void Paint() { int w = glutGet(GLUT_WINDOW_WIDTH)/2 ; // 计算视区宽度 int h = glutGet(GLUT_WINDOW_HEIGHT); // 计算视区高度 glClear(GL_COLOR_BUFFER_BIT); // 清除颜色缓存 Viewport(0, 0, w, h); // 左方视口 glColor3f(1, 0, 0); // 设置当前颜色,红色 glRectf(-0.8, -0.8, 0.8, 0.8); // 定义正方形 Viewport(w, 0, w, h); // 右方视口 glColor3f(0, 0, 1); // 设置当前颜色, 蓝色 glutSolidTeapot(0.6); // 定义犹他茶壶 glFlush(); // 强制OpenGL命令序列在有限的时间内完成执行 } int main(int argc, char *argv[]) { glutInit(&amp;argc, argv); // 初始化GLUT, 记录main()函数的参数 glutInitWindowSize(400,200); glutCreateWindow(&quot;多窗口演示&quot;); // 指定窗口标题 glutDisplayFunc(Paint); // 指定场景绘制函数 glutMainLoop(); // 开始执行 } 运行结果： 请使用OpenGL、GLU和GLUT编写一个多视口演示程序。要求： ① 在屏幕窗口左下角的1/4部分显示一个红色的填充矩形，该矩形的一对对角顶点是(-0.8,-0.8)和(0.8, 0.8)； ② 在屏幕窗口右下角的1/4部分显示一个绿色的填充犹他茶壶， 茶壶半径为0.6； ③ 在屏幕窗口上部居中的1/4部分显示一个蓝色的填充三角形，该 三角形的顶点分别是(-0.8, -0.8)、(0.8, -0.8)和(0, 0.8)；④ 程序窗口的大小为(200,200)，背景为黑色，标题为“多视口演示”。 #include &lt;gl/glut.h&gt; Viewport(int x, int y, int w, int h) { glViewport(x, y, w, h); // 定义视口 glLoadIdentity(); // 消除其他视口的影响, 函数介绍见后续章节 } void Paint() { int w = glutGet(GLUT_WINDOW_WIDTH) / 2; // 计算视区宽度 int h = glutGet(GLUT_WINDOW_HEIGHT) / 2; // 计算视区高度 glClear(GL_COLOR_BUFFER_BIT); // 清除颜色缓存 Viewport(0, 0, w, h); // 左方视口 glColor3f(1, 0, 0); // 设置当前颜色,红色 glRectf(-0.8, -0.8, 0.8, 0.8); // 定义正方形 Viewport(w, 0, w, h); // 右方视口 glColor3f(0, 1, 0); // 设置当前颜色, 绿色 glutSolidTeapot(0.6); // 定义犹他茶壶 Viewport(w/2, h, w, h); // 上方视口 glColor3f(0, 0, 1); // 设置当前颜色, 蓝色 glBegin(GL_TRIANGLES); // 定义填充三角形 { glVertex2f(-0.8, -0.8); // 指定二维顶点坐标 glVertex2f(0.8, -0.8); glVertex2f(0, 0.8); } glEnd(); glFlush(); // 强制OpenGL命令序列在有限的时间内完成执行 } int main(int argc, char *argv[]) { glutInit(&amp;argc, argv); // 初始化GLUT, 记录main()函数的参数 glutInitWindowSize(200,200); glutCreateWindow(&quot;多窗口演示&quot;); // 指定窗口标题 glutDisplayFunc(Paint); // 指定场景绘制函数 glutMainLoop(); // 开始执行 } 运行结果： 笔记构图快捷构图 矩形 void glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2); void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2); void glRecti(GLint x1, GLint y1, GLint x2, GLint y2); void glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2); void glRectdv(const GLdouble *v1, const GLdouble *v2); void glRectfv(const GLfloat *v1, const GLfloat *v2); void glRectiv(const GLint *v1, const GLint *v2); void glRectsv(const GLshort *v1, const GLshort *v2); 立方体 void glutSolidCube(GLdouble size);绘制实心立方体 void glutWireCube(GLdouble size);绘制网格线立方体 四面体 void glutSolidTetrahedron(void);绘制实心四面体 void glutWireTetrahedron(void);绘制网格线四面体 八面体 void glutSolidOctahedron(void);绘制实心八面体 void glutWireOctahedron(void);绘制网格线八面体 十二面体 void glutSolidDodecahedron(void);绘制实心十二面体 void glutWireDodecahedron(void);绘制网格线十二面体 二十面体 void glutSolidIcosahedron(void);绘制实心二十面体 void glutWireIcosahedron(void);绘制网格线二十面体 球面 void glutSolidSphere(GLdouble radius, int slices, int stacks);绘制实心球面 void glutWireSphere(GLdouble radius, int slices, int stacks);绘制网格线球面。 圆锥 void glutWireCone(GLdouble base, GLdouble height, GLint slices, GLintstacks);绘制一个实心圆锥 void glutSolidCone(GLdouble base, GLdouble height, GLint slices, GLintstacks);绘制一个网格线圆锥 圆环 void glutSolidTorus(GLdouble innerRadius, GLdouble outerRadius, GLintsides, GLint rings);绘制一个实心圆环 void glutWireTorus(GLdouble innerRadius, GLdouble outerRadius, GLintsides, GLint rings);绘制一个网格线圆环 犹他茶壶 void glutSolidTeapot(GLdouble size);绘制实心茶壶 void glutWireTeapot(GLdouble size);绘制网格线茶壶 自定义构图 void glBegin(GLenum mode); GL_POINTS：把每一个顶点作为一个独立的点。 GL_LINES：把每一对顶点作为一条独立的线段。 GL_LINE_STRIP：顶点依次相连成一组线段。 GL_LINE_LOOP：顶点依次相连成一组线段，并连接末顶点与首顶点。 GL_TRIANGLES：把每三个顶点作为一个独立的三角形。 GL_TRIANGLE_STRIP：三角形带，顶点n、n+1和n+2定义第n个三角形。 GL_TRIANGLE_FAN：三角形扇形，顶点1、n+1和n+2定义第n个三角形。 GL_QUADS：把每四个顶点作为一个独立四边形。 GL_QUAD_STRIP：四边形带，顶点2n-1、2n、2n+2和2n+1定义第n个四边形。可能形成有交叉的四边形，不好把握。 GL_POLYGON：所有顶点作为一个简单多边形。最好不要定义凹多边形，多边形在处理时会分解成三角形扇形，凹多边形可能得不到预期效果。","link":"/six/"},{"title":"Sublime Text3 配置C、C++环境，并且能调用cmd","text":"准备工作安装Sublime Text3下载链接1 下载链接2 安装过程不在这里啰嗦，汉化等功能自行百度 下载MinGW下载链接 下载安装完成之后，要记住安装路径，配置的时候要用到 配置工作配置环境变量 【此电脑】-&gt;鼠标右键【属性】-&gt;【高级系统设置】-&gt;【环境变量】-&gt;【系统变量】 找到Path变量，添加上你刚才下载的MinGW的安装路径 桌面打开【cmd】，输入g++ -v或者gcc -v,出现如下内容即配置成功 配置Sublime Text3默认Sublime Text3 中的编译系统是不会调用cmd的，因此我们需要新建满足我们需求的编译系统 【打开sublime】-&gt;【工具】-&gt;【编译系统】-&gt;【新建编译系统】，会出现如下内容 新建C++编译系统将内容替换为如下内容 12345678{ &quot;cmd&quot;: [&quot;g++&quot;, &quot;${file}&quot;, &quot;-fexec-charset=gbk&quot;,&quot;-o&quot;, &quot;${file_path}/${file_base_name}&quot;,&quot;-Wall&quot; ,&quot;&amp;&amp;&quot;,&quot;start&quot;,&quot;cb_console_runner.exe&quot;,&quot;${file_path}/${file_base_name}&quot;], &quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;, &quot;working_dir&quot;: &quot;${file_path}&quot;, &quot;selector&quot;: &quot;source.c, source.c++&quot;, &quot;shell&quot;: true, &quot;encoding&quot;:&quot;cp936&quot; } 保存命名为C++.sublime-build，当然也可以命名为其他你自己可以记住的 新建C 编译系统将内容替换为如下内容 12345678{ &quot;cmd&quot;: [&quot;gcc&quot;, &quot;${file}&quot;, &quot;-fexec-charset=gbk&quot;,&quot;-o&quot;, &quot;${file_path}/${file_base_name}&quot;, &quot;&amp;&quot;, &quot;start&quot;, &quot;cmd&quot;, &quot;/c&quot;, &quot;${file_base_name} &amp; echo. &amp; pause&quot;], &quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;, &quot;working_dir&quot;: &quot;${file_path}&quot;, &quot;selector&quot;: &quot;source.c, source.c++&quot;, &quot;shell&quot;: true, &quot;encoding&quot;:&quot;cp936&quot;} 保存命名为C.sublime-build，当然也可以命名为其他你自己可以记住的 测试C++源码： 12345678910#include &lt;iostream&gt;using namespace std;int main(int argc, char const *argv[]){ int n; cin &gt;&gt; n; cout &lt;&lt; &quot;芜湖，起飞：&quot; &lt;&lt; n &lt;&lt; endl; return 0;} 运行结果： C源码： 123456789#include &lt;stdio.h&gt;int main(int argc, char const *argv[]){ int n; scanf(&quot;%d&quot;,&amp;n); printf(&quot;芜湖，起飞：%d\\n&quot;,n); return 0;} 运行结果： 参考资料Sublime Text 配置C++运行，带黑窗口，支持中文[windows]","link":"/sublime-conf/"},{"title":"FTP、SFTP、SCP的区别","text":"它们是什么？FTP 是TCP/IP网络上两台计算机传送文件的协议，FTP是在TCP/IP网络和INTERNET上最早使用的协议之一，它属于网络协议组的应用层。FTP客户机可以给服务器发出命令来下载文件，上载文件，创建或改变服务器上的目录。相比于HTTP，FTP协议要复杂得多。复杂的原因，是因为FTP协议要用到两个TCP连接，一个是命令链路，用来在FTP客户端与服务器之间传递命令；另一个是数据链路，用来上传或下载数据。FTP是基于TCP协议的，因此iptables防火墙设置中只需要放开指定端口（21 + PASV端口范围）的TCP协议即可。 FTP工作模式： PORT（主动）方式的连接过程是：客户端向服务器的FTP端口（默认是21）发送连接请求，服务器接受连接，建立一条命令链路。当需要传送数据时，客户端在命令链路上用PORT命令告诉服务器：“我打开了一个1024+的随机端口，你过来连接我”。于是服务器从20端口向客户端的1024+随机端口发送连接请求，建立一条数据链路来传送数据。PASV（Passive被动）方式的连接过程是：客户端向服务器的FTP端口（默认是21）发送连接请求，服务器接受连接，建立一条命令链路。当需要传送数据时，服务器在命令链路上用PASV命令告诉客户端：“我打开了一个1024+的随机端口，你过来连接我”。于是客户端向服务器的指定端口发送连接请求，建立一条数据链路来传送数据。PORT方式，服务器会主动连接客户端的指定端口，那么如果客户端通过代理服务器链接到internet上的网络的话，服务器端可能会连接不到客户端本机指定的端口，或者被客户端、代理服务器防火墙阻塞了连接，导致连接失败。PASV方式，服务器端防火墙除了要放开21端口外，还要放开PASV配置指定的端口范围。 SFTP 安全文件传送协议。可以为传输文件提供一种安全的加密方法。SFTP与 FTP有着几乎一样的语法和功能。SFTP为SSH的一部份，是一种传输文件到服务器的安全方式。在SSH软件包中，已经包含了一个叫作SFTP(Secure File Transfer Protocol)的安全文件传输子系统，SFTP本身没有单独的守护进程，它必须使用sshd守护进程（端口号默认是22）来完成相应的连接操作，所以从某种意义上来说，SFTP并不像一个服务器程序，而更像是一个客户端程序。SFTP同样是使用加密传输认证信息和传输的数据，所以，使用SFTP是非常安全的。但是，由于这种传输方式使用了加密/解密技术，所以传输效率比普通的FTP要低得多，如果您对网络安全性要求更高时，可以使用SFTP代替FTP。 登陆远程主机： sftp user@host 针对本机的命令都加上l: lcd，lpwd 将本机文件上传到远程： put filename.txt [some/directory] 将当前文件夹下的文件上传到远程： mput *.* // multiple 下载远程文件到本地: get filename.file [some/directory] 下载目录下所有远程文件到本地： mget *.* [some/directory] 退出： bye/exit/quit SCP SCP就是Secure copy，是用来进行远程文件复制的，并且整个复制过程是加密的。数据传输使用ssh，并且和使用和ssh相同的认证方式，提供相同的安全保证。 拷贝本地文件到远程： scp filename.txt user@host:some/directory 拷贝本地文件到远程，使用指定端口： scp -P 2234 filename.txt user@host:some/directory 拷贝多个文件到远程home： scp filename1.txt filename2.txt user@host:~ 拷贝远程文件到本地： scp user@host:directory/filename.txt /directory 拷贝远程文件夹到本地： scp -r user@host:directory/folder . 拷贝远程文件到远程： scp user@host1:directory/filename.txt user@host1:directory 参考资料 文件传输协议FTP、SFTP和SCP","link":"/three/"},{"title":"uni-app学习基础","text":"一、uni-app的初体验1.1开发方式 通过HBuilderX可视化界面 不多介绍 通过vue-cli命令行 1.2脚手架搭建项目 环境安装 全局安装vue-cli 1npm install -g @vue/cli 创建项目 使用正式版（对应HBuilderX最新正式版） 1vue create dcloudio/uni-preset-vue my-project 使用alpha版（对应HBuilderX最新alpha版） 1vue create -p dcloudio/uni-preset-vue#alpha my-alpha-project 此时，会提示选择项目模板，初次体验建议选择 hello uni-app 项目模板，当然也可以使用默认模板（本项目是默认模板） 启动项目（微信小程序） 1npm run dev:mp-weixin 当然，还有其他版本：支付宝小程序、qq小程序等 微信小程序开发者工具导入项目 需要把 my-project/dist/dev/mp-weixin 这个目录导入微信小程序开发者工具其中 二、项目结构介绍src/ 三、样式和sass 支持小程序的 rpx 和h5的 vw 、 vh rpx为小程序单位：750rpx = 屏幕宽度 vw 、vh是h5单位，100vw = 屏幕的宽度，100vh = 屏幕的高度 内置有sass的配置，只需要安装对应的依赖即可：npm install sass-loader node-sass vue组件中，在style标签上加上属性 &lt;style lang='scss'&gt; 即可 四、基本语法4.1数据的展示定义在js的**data**中定义数据 123456data(){ return{ msg:&quot;hello&quot;, color:'red' }} 使用 在template中通过****来展示 {{msg}} 在标签的属性上通过 :data-index='数据' 来使用，从而数据对应标签属性 &lt;view :data-color=&quot;color&quot;&gt;nice&lt;/view&gt; 4.2数据的循环 通过 v-for 来指定要循环的数组 item 和 index 分别为循环项和循环索引 :key指定唯一的属性，用来提高循环效率 123456789data(){ return{ list:[ {id:001,text:&quot;苹果🍎&quot;}, {id:002,text:&quot;香蕉🍌&quot;}, {id:003,text:&quot;樱桃🍒&quot;} ] }} 123&lt;view v-for=&quot;(item,index) in list&quot; :key=&quot;item.id&quot;&gt;{{index}} -- {{item.id}} -- {{item.text}}&lt;/view&gt; 4.3条件编译 通过 v-if 来决定显示和隐藏 通过删除了标签来实现，不适合做频繁的切换显示 通过 v-show 来决定显示和隐藏 通过 display: none; 来实现，适合做频繁的切换显示 123456&lt;view&gt; &lt;view v-if=&quot;false&quot;&gt;v-if&lt;/view&gt; &lt;view v-show=&quot;false&quot;&gt;v-show&lt;/view&gt; &lt;!-- 通过变量来控制 --&gt; &lt;view v-if=&quot;isShow&quot;&gt;显示或隐藏&lt;/view&gt;&lt;/view&gt; 4.4计算属性 可以理解为是对 data 中的数据提供了一种加工或者过滤的能力 通过 computed 来定义计算属性 12345678&lt;!-- 计算能力--&gt;&lt;view&gt; {{getMoney}}&lt;/view&gt;&lt;!-- 过滤能力 --&gt;&lt;view v-for=&quot;(item,index) in filterList&quot; :key=&quot;item.id&quot;&gt;{{index}} -- {{item.id}} -- {{item.text}}&lt;/view&gt; 123456789101112131415computed: { getMoney(){ return '￥'+ this.money; }, filterList(){ //要把 id&gt;0 的数据项都过滤掉 return this.list.filter(v =&gt; v.id &lt;= 0); }, processList(){ return this.list.map(v =&gt; { v.color = &quot;red&quot;; return v; }) }} 五、事件 注册事件 @click= &quot;handleClick&quot; 定义事件监听函数，需要在 methods 中定义 事件的传参 12&lt;view @click=&quot;handleClick&quot;&gt;please click here&lt;/view&gt;&lt;view data-index=&quot;ppp&quot; @click=&quot;printClick(1,$event)&quot;&gt;click to print content of data-index&lt;/view&gt; 12345678910methods: { handleClick(){ console.log(&quot;点击生效了！&quot;); }, printClick(obj,event){ console.log(obj); console.log(event); console.log(event.currentTarget.dataset.index); }} 六、组件6.1组件的简单使用 组件的定义 在 src 目录下新建文件夹 components 用来存放组件 在 components 目录下直接新建组件 *.vue 组件的引入 在页面中引入组件 import 组件名 from '组件路径' 组件的注册 在页面中的实例中，新增属性 components 属性 components 是一个对象，把组件放进去注册 组件的使用 在页面的标签中，直接使用引入的组件 `&lt;组件&gt;&lt;/组件&gt; components/img-border.vue 123456789101112&lt;template&gt; &lt;image src=&quot;http://example.com.1.jpg&quot;&gt;&lt;/image&gt;&lt;/template&gt;&lt;script&gt;export default { }&lt;/script&gt;&lt;style&gt;&lt;/style&gt; pages/index/index.vue 1234567891011121314151617181920&lt;template&gt; &lt;view&gt; &lt;imgBorder&gt;&lt;/imgBorder&gt; &lt;!-- 或者下面这种格式,这两种格式是等价的 --&gt; &lt;img-border&gt;&lt;/img-border&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;// @ 对应的目录是 src/import imgBorder from &quot;@/components/img-border&quot;;export default { components: { imgBorder }}&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 6.2组件传参父向子传递参数，通过属性的方式 父页面向子组件 imgBorder 或者 img-border 通过属性名 src 传递了一个数组数据 子组件通过 props 进行接收数据· pages/index/index.vue 123456789101112131415161718192021&lt;template&gt; &lt;view&gt; &lt;imgBorder :src=&quot;mySrc&quot;&gt;&lt;/imgBorder&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;// @ 对应的目录是 src/import imgBorder from &quot;@/components/img-border&quot;;export default { data(){ return { mySrc:&quot;http://www.baidu.com/example.png&quot; } }, components: { imgBorder }}&lt;/script&gt; components/img-border.vue 123456789101112&lt;template&gt; &lt;!-- 把props中的src看作是data中的变量一样来使用 --&gt; &lt;image :src=&quot;src&quot;&gt;&lt;/image&gt;&lt;/template&gt;&lt;script&gt;export default { props:{ src:String }}&lt;/script&gt; 子向父传递参数，通过触发事件的方式 子组件通过触发事件的方式向父组件传递数据 父组件通过监听事件的方式来接收数据 components/img-border.vue 123456789101112131415161718&lt;template&gt; &lt;image @click=&quot;handleClick&quot; :src=&quot;src&quot;&gt;&lt;/image&gt;&lt;/template&gt;&lt;script&gt;export default { props:{ src:String }, methods:{ handleClick(){ //子向父传递数据通过 触发事件 //this.$emit(&quot;自定义的事件名称&quot;,&quot;要传递的参数&quot;)； this.$emit(&quot;srcMsg&quot;,this.src); } }}&lt;/script&gt; pages/index/index.vue 123456789101112131415161718192021222324252627&lt;template&gt; &lt;view&gt;子组件传递过来的路径：{{childSrc}}&lt;/view&gt; &lt;view&gt; &lt;imgBorder @srcMsg=&quot;handleSrcMsg&quot; :src=&quot;mySrc&quot;&gt;&lt;/imgBorder&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;// @ 对应的目录是 src/import imgBorder from &quot;@/components/img-border&quot;;export default { data(){ return { mySrc:&quot;http://www.baidu.com/example.png&quot;, childSrc:&quot;&quot; } }, components: { imgBorder }, methods:{ handleSrcMsg(e){ this.childSrc = e; } }}&lt;/script&gt; 通过全局数据传递参数 通过挂载vue的原型上 在main.js或者任何有 import Vue from 'vue' 的页面内定义 1Vue.prototype.baseURL = &quot;http://www.baidu.com&quot; 当作是 data 中的变量一样来使用 1this.baseURL 通过globalData的方式 在 App.vue 中定义 12345678910&lt;script&gt; export default { onShow: function(){ }, globalData:{ base:&quot;www.360.com&quot; } }&lt;/script&gt; 使用 1getApp().globalData.base 修改 1getApp().globalData.base = &quot;xxx&quot; 6.3组件插槽 标签其实也是数据中的一种，想实现动态的给子组件传递标签，就可以使用插槽slot 通过slot来实现占位符 components/my-form.vue 1234567891011121314151617&lt;template&gt; &lt;view class=&quot;form&quot;&gt; &lt;view class=&quot;form_title&quot;&gt;标题&lt;/view&gt; &lt;view class=&quot;form_content&quot;&gt;内容&lt;/view&gt; &lt;!-- 插槽 来占位置 --&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;export default { }&lt;/script&gt;&lt;style&gt;&lt;/style&gt; pages/index/index.vue 123456789101112131415161718192021222324&lt;template&gt; &lt;view&gt; &lt;myForm&gt; &lt;view&gt; &lt;imput placeholder=&quot;please input&quot; type=&quot;text&quot; /&gt; &lt;radio&gt;&lt;/radio&gt; &lt;checkbox&gt;&lt;/checkbox&gt; &lt;/view&gt; &lt;/myForm&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;// @ 对应的目录是 src/import myForm from &quot;@/components/my-form&quot;;export default { components: { myForm }}&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 七、生命周期 uni-app框架的生命周期结合了vue和微信小程序的生命周期 全局的APP中使用 onLaunch 表示应用启动时 页面中，使用 onLoad 或者 onShow 分别表示页面加载完毕时和页面显示时 组件中使用 mounted 表示组件挂载完毕时 uniapp生命周期 Vue生命周期","link":"/uni-app%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"},{"title":"vue跨域配置解析","text":"前言跨域这个问题其实老生常谈了，简单来讲就是，浏览器由于同源策略规定，AJAX请求只能发给同源的网址，否则就报错。 所谓同源，就是域名、协议、端口相同。 同源策略是浏览器的行为，是为了保护本地数据不被JavaScript代码获取回来的数据污染，因此拦截的是客户端发出的请求回来的数据接收，即请求发送了，服务器响应了，但是无法被浏览器接收。 举个例子我们请求一下百度首页： 1234567this.$axios.get(&quot;https://www.baidu.com&quot;).then(res=&gt;{ console.log(res)}).catch(err=&gt;{ console.log(err)}) 然后，浏览器检查一下控制台，报错情况如下： 1234Access to XMLHttpRequest at 'https://www.baidu.com/' from origin 'http://localhost:8080' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.list.vue?61b8:36 Error: Network Error at createError (createError.js?16d0:16) at XMLHttpRequest.handleError (xhr.js?ec6c:84) 虽然报错了，但是浏览器其实是获取到数据的，只不过这样报错，不显示数据。 接下来让我们解决这个问题。 Vue2配置BaseUrl首先在main.js中，配置下我们访问的Url前缀： 12345678910111213141516import Vue from 'vue'import App from './App'import Axios from 'axios'Vue.prototype.$axios = AxiosAxios.defaults.baseURL = '/test'Axios.defaults.headers.post['Content-Type'] = 'application/json';Vue.config.productionTip = false/* eslint-disable no-new */new Vue({ el: '#app', components: { App }, template: '&lt;App/&gt;'}) 关键代码是：Axios.defaults.baseURL = '/test'，这样每次发送请求都会带一个/test的前缀。 配置代理修改config文件夹下的index.js文件，在proxyTable中加上如下代码： 1234567'/test':{ target: &quot;https://www.baidu.com&quot;, changeOrigin:true, pathRewrite:{ '^/test':'/' }} 这段代码，vue-cli启动了http-proxy-middleware代理服务。 第一个/test，相当于是当请求链接遇到/test时，会将/test拼接到target的链接下，比如我们在写axios请求的时候，只用写成/test/1就可以代表https://www.baidu.com/test/1。 1234// 举例 原先的请求http://localhost:8080/test// 代理后的请求https://www.baidu.com/test 然后就是pathRewrite起作用了，它能够用正则匹配到相应的字符段，然后进行路径替换，将前者替换为后者，这里看个人习惯来命名参数。也就是说pathRewrite起重新加工处理的作用。 1234// 代理后的请求https://www.baidu.com/test// 重写后的请求https://www.baidu.com/ 如果想了解更多关于pathRewrite参数的讲解和实例，可以看看这里 http-proxy-middleware中的pathRewrite pathRewrite 修改请求Url1234567this.$axios.get(&quot;/&quot;).then(res=&gt;{ console.log(res)}).catch(err=&gt;{ console.log(err)}) 重启服务ctrl + c终端后，再重新启动一下，就OK了，就能够正常请求到了。 这是控制台打印出来的内容： 1{data: &quot;&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;\\n\\n\\n &lt;html&gt;&lt;head&gt;…5a9387c5b.js\\&quot;&gt;&lt;/script&gt;\\n&lt;/body&gt;\\n \\n\\t&lt;/html&gt;&quot;, status: 200, statusText: &quot;OK&quot;, headers: {…}, config: {…}, …} Vue3基本上跟vue2一样，只是配置代理的时候有点不同。 配置代理由于vue3删除了config文件夹，所以没了对应的index.js文件，因此我们要自己新建一个config文件。 在项目根目录下新建一个vue.config.js文件，添加基础内容如下： 12345678910111213module.exports = { outputDir: 'dist', //build输出目录 assetsDir: 'assets', //静态资源目录（js, css, img） lintOnSave: false, //是否开启eslint devServer: { open: true, //是否自动弹出浏览器页面 host: &quot;localhost&quot;, port: '8080', https: false, //是否使用https协议 hotOnly: false, //是否开启热更新 proxy: null, }} 修改devServer下的proxy： 123456789proxy: { '/test': { target: 'https://www.baidu.com', //API服务器的地址 changeOrigin: true, pathRewrite: { '^/test': '/' } }} 参考文档 Axiso解决跨域访问 思否 Vue-cli proxyTable 解决开发环境的跨域问题","link":"/vue-cross-domin-config/"},{"title":"uni-app中封装axios请求","text":"安装安装axios 1npm install axios --save 安装qs 1npm install qs --save 配置1.在src/下新建一个utils/request.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import axios from &quot;axios&quot;import qs from &quot;qs&quot;import Vue from &quot;vue&quot;// Full config: https://github.com/axios/axios#request-config// axios.defaults.baseURL = process.env.baseURL || process.env.apiUrl || '';// axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;// axios.defaults.headers.post[&quot;Content-Type&quot;] =// &quot;application/x-www-form-urlencoded;charset=UTF-8&quot;;const service = axios.create({ withCredentials: true, crossDomain: true, baseURL: Vue.prototype.baseURL, //这个baseURL是我在main.js下配置的请求url timeout: 6000})// request拦截器,在请求之前做一些处理service.interceptors.request.use( config =&gt; { // if (store.state.token) { // // 给请求头添加user-token // config.headers[&quot;user-token&quot;] = store.state.token; // } config.method === 'post' ? config.data = qs.stringify({ ...config.data }) : config.params = { ...config.params }; console.log('请求拦截成功') return config; }, error =&gt; { console.log(error); // for debug return Promise.reject(error); });//配置成功后的拦截器service.interceptors.response.use(res =&gt; { if (res.data.status == 200) { return res.data } else { return Promise.reject(res.data.msg); }}, error =&gt; { return Promise.reject(error)})axios.defaults.adapter = function(config) { //自己定义个适配器，用来适配uniapp的语法 return new Promise((resolve, reject) =&gt; { // console.log(config) var settle = require('axios/lib/core/settle'); var buildURL = require('axios/lib/helpers/buildURL'); uni.request({ method: config.method.toUpperCase(), url: config.baseURL + buildURL(config.url, config.params, config.paramsSerializer), header: config.headers, data: config.data, dataType: config.dataType, responseType: config.responseType, sslVerify: config.sslVerify, complete: function complete(response) { console.log(&quot;执行完成：&quot;, response) response = { data: response.data, status: response.statusCode, errMsg: response.errMsg, header: response.header, config: config }; settle(resolve, reject, response); } }) })}export default service 2.在src/下新建一个api/user.js，当作各种请求汇总文件夹 12345678910111213//引入刚才创建的request.jsimport request from '@/utils/request' //GTE 传参需要用 params//POST 传参需要用 dataexport function getMsg() { return request({ url: '/homepage/vertical', method: 'get' })} 3.可以结合Vuex在store/actions下使用，也可以直接使用，下面演示直接在pages/index/index.vue使用 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; //引入函数 import { getMsg } from '@/api/user' export default { data() { return { } }, onLoad() { getMsg().then(res =&gt; { console.log(&quot;请求res内容&quot;,res); }) .catch(err =&gt; { console.log(&quot;请求err内容&quot;,err) }) } }&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 结果显示：请求到了内容，说明调通了","link":"/uni-app%E4%B8%AD%E5%B0%81%E8%A3%85axios%E8%AF%B7%E6%B1%82/"},{"title":"解决Win10更新后网络图标bug","text":"很久之前我自己把我的Win10的更新关闭了，最近发现有新鲜的功能，于是乎就更新了Win10系统，结果就出现了奇怪的问题： 我明明连上了网络，但是右下角的网络还是未连接网络状态，查看相应的以太网连接或者WiFi连接，显示无Internet。对于我这种微强迫症而言，很是难受。 于是就想办法解决…… 尝试一开始，我是通过右键点击网络图标的疑难解答，然后它建议我重置网络，我想可能确实是因为网络缓存的问题，于是就重置了，结果也确实比较满意：能够正常显示了。 但是，最怕的就是但是了，没几天，就又出现类似的问题了，于是我就又开始寻找办法……. 后来，又看到了一种方法，但是并没有效果……这里贴出来展示下。 问题所在这里粘贴原作者的解析和链接 原因分析：经注册表选项比对，发现问题出在连网返回值功能有了变化。原理是每当连网后，系统会自动向微软的http://dns.msftncsi.com发出请求，然后返回一个NCSI.txt的值，这一值如果正确时，则确认为已连网。而Win10最近的版本中，这个返回服务器和值有了新变化并反映为6个注册表项中。这些变化因国内部分运行商的网络重定向，不能得到正确的反馈，因此出现实际能上网确显示为无internet的问题。 下图中第一张图是出错的注册表项： 第二张是18362版之前正确的注册表项： 其中被选中标成蓝色的项，改回为图中所显示的值，EnableActiveProbing仍恢复为1，重启系统后，网络即能恢复正常，此方法已在多台电脑上测试有效，希望能顺利解决大家的问题！注册表项具体在：\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\NlaSvc\\Parameters\\Internet 之下，请对照图中成值修改！！！","link":"/win10-network-icon-bug/"},{"title":"nodejs中的package.json相关问题","text":"将之前遇到的一些关于node工程目录的问题总结一下，偶尔看看来加深印象，未来会持续更新内容。 版本号中~和^的区别node项目的package.json文件列出了项目所依赖的插件和库，同时也给出了对应的版本，但是在版本前面还有符号：^（插入符号）和~（波浪符号）,介绍下两个符号的区别： 1234&quot;dependencies&quot;: { &quot;axios&quot;: &quot;^0.18.0&quot;, &quot;cross-env&quot;: &quot;~5.2.0&quot;} ^插入符号它将会把当前库的版本更新到当前主版本（也就是第一位数字）中最新的版本。放到我们的例子中是： 1&quot;axios&quot;: &quot;^0.18.0&quot; 这个库会去匹配0.x.x中最新的版本，但是它不会自动更新到1.0.0。 ~波浪符号它会更新到当前次版本号（也就是中间的那位数字）中最新的版本。放到我们的例子中就是： 1&quot;cross-env&quot;: &quot;~5.2.0&quot; 这个库会去匹配更新到5.2.x的最新版本，如果出了一个新的版本为5.3.0，则不会自动升级。 ~波浪符号是曾经npm安装时候的默认符号，现在已经改为了^插入符号。 package与package-lock区别 package.json的作用 package.json记录你项目中所需要的所有模块，当你执行npm install的时候，node会先从package.json中读取所有dependencies信息，然后根据dependencies中的信息与node_modules中的模块进行对比，没有的直接下载，已有的检查更新（最新版本的nodejs不会更新，因为有package-lock.json，下面再说）。 另外，package.json只记录你通过npm install方式安装的模块信息，而这些模块所依赖的其他子模块的信息不会记录。 package-lock.json的作用 package-lock.json锁定所有模块的版本号，包括主模块和所有依赖子模块。当你执行npm install的时候，node从package.json读取模块名称，从package-lock.json中获取版本号，然后进行下载或者更新。 因此，正因为有了package-lock.json锁定版本号，所以当你执行npm install的时候，node不会自动更新package.json中的模块，必须用npm install packagename（自动更新小版本号）或者npm install packagename@x.x.x（指定版本号）来进行安装才会更新，package-lock.json中的版本号也会随着更新。 其他当package.json与package-lock.json都不存在，执行npm install时，node会重新生成package-lock.json文件，然后把node_modules中的模块信息全部记入package-lock.json文件，但不会生成package.json文件，此时，你可以通过npm init --yes来初始化生成package.json文件。 总结项目中引入的包版本号之前经常会加^，每次在执行npm install之后，下载的包都会发生变化，为了系统的稳定性考虑，每次执行完npm install之后会创建或者更新package-lock文件。该文件记录了上一次安装的具体的版本号，相当于是提供了一个参考，在出现版本兼容性问题的时候，就可以参考这个文件来修改版本号即可。","link":"/package-problem-in-node/"},{"title":"正则表达式构造函数的使用","text":"通常情况下，我们构建正则表达式的方式都是：由斜杠 (/) 直接包围的表达式。但是，有些特殊情况，我们无法通过这种方式构建出来：比如需要根据用户所选择的字段，来进行构建一个正则表达式。这个时候我们无法在程序代码中定死一个表达式，而应该根据参数来构建正则表达式，此时就需要用到正则表达式的构造函数了。 1new RegExp(pattern[, flags]) 而我们平常使用的那种形式，叫做字面量：由斜杠 (/) 包围而不是引号包围。 1const regexp = /abc/i; // 字面量形式 构造函数的字符串参数：由引号而不是斜杠包围。 1const regexp = new RegExp('abc', 'i'); // 首个参数为字符串模式的构造函数 另外，构造函数也有字面量参数 1const regexp = new RegExp(/abc/, 'i'); // 首个参数为常规字面量的构造函数 我们应对开头所说的根据参数来构建正则表达式，就要用到字符串参数的构造函数: 12345// 需要根据用户所输入的字符串，进行校验：以用户输入的字符串为开头的字符串const targetStr = 'xxxxxxxxx'const userInputStr = 'abc'const regexp = new RegExp(`^${userInputStr}`)regexp.test(targetStr) 思考：正则表达式的字面量形式和字符串形式，在构建的时候还有什么差异？ 答：由于是字符串，所以对于一些特定字符用转义符（\\）进行转义","link":"/regexp-constructor-func/"},{"title":"event-bug结合vue生命周期使用","text":"event-bus 在vue中使用时，为了避免在vue组件未实际生效时，event-bus就进行事件的监听。因此需要结合vue的生命周期进行代理实现。 1234567891011121314151617181920212223242526272829303132333435// 定义一个event-busimport mitt from 'mitt'class CustomEventBus { constructor() { this.keys = {} this.emitter = mitt() } emit(key, ...args) { this.keys[key.toUpperCase()] = key this.emitter.emit(key, ...args) } on(key, callback) { this.emitter.on(key, callback) } // 结合生命周期 onInVue(key, callback, vm) { const callbackProxy = (...args) =&gt; { if (vm._inactive) return callback(...args) } this.emitter.on(key, callbackProxy) vm.$once('hook:beforeDestroy', () =&gt; { this.emitter.off(key, callbackProxy) }) } off(key, callback) { this.emitter.off(key, callback) }}export default new CustomEventBus()","link":"/custom-eventbus-with-vue-life-circle/"},{"title":"js实现sleep函数","text":"⚠️js 中是没有 sleep 函数，那应该怎么实现呢？ 经过尝试，有 3 种方法实现：setTimeout、Promise、Generator 123456789101112const sleep = (seconds) =&gt; { return new Promise((resolve) =&gt; { setTimeout(() =&gt; resolve(), seconds) })}const func = async () =&gt; { console.log(&quot;1&quot;) await sleep(1000)console.log(&quot;2&quot;)}func() 效果展示","link":"/sleep-func/"},{"title":"css中的关系选择器","text":"⚠️后代选择器和子代选择器比较常用，还有两个选择器需要记住 12345678/* 后代选择器——典型用单个空格（&quot; &quot;）字符——组合两个选择器 */body article p/* 子代关系选择器是个大于号（&gt;），只会在选择器选中直接子元素的时候匹配 */article &gt; p/* 邻接兄弟选择器（+）用来选中恰好处于另一个在继承关系上同级的元素旁边的物件，只能是邻接 */p + img/* 通用兄弟选择器（~）用来选中，一个元素后的兄弟元素，即使它们不直接相邻，在前面选不到 */p ~ img","link":"/relationship-selector-in-CSS/"},{"title":"svg中 path 的路径命令","text":"路径命令是对要绘制的路径的说明。每一个命令由代表命令的字母和代表参数的数字组成。 SVG 定义了六种路径命令类型，一共 20 条命令： MoveTo(移动到)：M、m LineTo(画线至)：L、l、H、h、V、`v BezierCurve(贝塞尔曲线) 二次贝塞尔曲线：Q、q、T、t 三次贝塞尔曲线：C、c、S、s 椭圆曲线：A、a ClosePath(封闭路径)：Z、z 本文主要是针对以上命令，进行整理 路径命令先来看一下这一段 svg 代码，第一眼看上去是一脸懵逼状态，等我们梳理完，相信能对这段代码有一段非常非常清晰的认识和理解！ 12345678910&lt;svg viewBox=&quot;0 0 100 100&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt; &lt;path fill=&quot;none&quot; stroke=&quot;red&quot; d=&quot;M 10,30 A 20,20 0,0,1 50,30 A 20,20 0,0,1 90,30 Q 90,60 50,90 Q 10,60 10,30 z&quot; /&gt;&lt;/svg&gt; MoveTo(移动到) MDN 文档解释 Moveto 指令可以被想象成拎起绘图笔，落脚到另一处。即，从当前位置（Po; {xo, yo}），移动到新的位置（Pn; {xn, yn}），且新的位置与 Po 之间不会绘制线段。 命令 M：(x, y)+ 将当前位置移动到坐标 x,y。后续子坐标序列将被解释为隐式的绝对位置的 LineTo（L）命令的参数（见下方）。公式： Pn = {x, y} m：(dx, dy)+ 将当前位置沿 x 轴移动 dx，沿 y 轴移动 dy。后续子坐标序列将被解释为隐式的相对位置的 LineTo（l）命令的参数（见下方）。公式： Pn = {xo + dx, yo + dy} 简单来说 就是在一张白纸上，我们拿起笔，挪到了指定的位置上，注意，此时并不会产生线条，没有落笔。另外，大写字母命令是绝对位置坐标，小写字母命令是相对位置坐标。 +号指的是可以是多个位置对，比如 M 10,30 20,30 40,50，可以方便不用多写几行 M 的命令 LineTo(画线至) MDN 文档解释 Lineto 指令将绘制一条直线段。这个直线段从当前位置（Po; {xo, yo}）移到指定位置（Pn; {xn, yn}）。然后，指定位置（Pn）将变成下一个命令中的当前位置（Po′）。 命令 L：(x, y)+ 在当前位置和指定位置 x,y 之间绘制一条线段。后续子坐标序列将被解释为隐式的绝对位置的 LineTo（L）命令的参数。公式： Po′ = Pn = {x, y} l：(dx, dy)+ 在当前位置和指定位置之间绘制一条线段，指定位置为当前位置沿 x 轴偏移 dx 以及沿 y 轴偏移 dy 处。后续子坐标序列将被解释为隐式的相对位置的 LineTo（L）命令的参数。公式： Po′ = Pn = {xo + dx, yo + dy} H：x+ 在当前位置与指定位置之间绘制一条水平线段。指定位置由 x 参数和当前位置的 y 坐标指定。后续子序列的值将被解释为隐式的绝对位置的 LineTo（H）命令的参数。公式： Po′ = Pn = {x, yo} h：dx+ 在当前位置与指定位置之间绘制一条水平线段。指定位置由当前位置沿 x 轴偏移 dx 的 x 坐标和当前位置的 y 坐标指定。后续子序列的值将被解释为隐式的相对位置的 LineTo（h）命令的参数。公式： Po′ = Pn = {xo + dx, yo} V：y+ 在当前位置与指定位置之间绘制一条垂直线段。指定位置由 y 参数和当前位置的 x 坐标指定。后续子序列的值将被解释为隐式的绝对位置的 LineTo（V）命令的参数。公式： Po′ = Pn = {xo, y} v：dy+ 在当前位置与指定位置之间绘制一条垂直线段。指定位置由当前位置沿 y 轴偏移 dy 的 y 坐标和当前位置的 x 坐标指定。后续子序列的值将被解释为隐式的相对位置的 LineTo（v）命令的参数。公式： Po′ = Pn = {xo, yo + dy} 简单来说 在一张白纸上，我们拿起笔，找到指定的目标位置，然后拿一根尺子📏，连接目标位置和当前位置。此时因为落笔了，所以就会产生线条。 L语义化理解，就是 Line；H就是 Horizontal(水平的)，水平方向移动；V就是 Vertical(垂直的)，垂直方向移动 大小写命令和+，见 MoveTo 命令 BezierCurve(贝塞尔曲线)n阶贝塞尔曲线需要有个 n-1个控制点（n &gt;= 1）。 当 n =1 时，贝塞尔曲线只是一条两点之间的直线。 关于贝塞尔曲线的推导公式，可以看参考资料下的维基百科内容，这里只讨论如何看懂贝塞尔曲线。 二次贝塞尔曲线二次贝塞尔曲线是使用三个点定义的平滑曲线，它的控制点有 1 个： MDN 文档解释 起始点（当前位置） P0&gt; = {x0, y0} 终点 P1&gt; = {x1, y1} 控制点 P2 = {x2, y2}（控制曲率） 命令 Q：(x1,y1, x,y)+ 在当前位置和终点 x,y 之间绘制一条二次贝塞尔曲线。控制点通过 x1,y1 指定。后续成对的坐标序列将被解释为隐式的绝对位置的二次贝塞尔曲线（Q）命令的参数。公式：Po′ = Pn = {x, y} ; Pc = {x1, y1} q：(dx1,dy1, dx,dy)+ 在当前位置和终点（终点为当前位置沿 x 轴偏移 dx 以及沿 y 轴偏移 dy 处）之间绘制一条二次贝塞尔曲线。控制点为当前位置（曲线的起始点）沿 x 轴偏移 dx1 以及沿 y 轴偏移 dy1 处。后续成对的坐标序列将被解释为隐式的相对位置的二次贝塞尔曲线（q）命令的参数。公式：Po′ = Pn = {xo + dx, yo + dy} ; Pc = {xo + dx1, yo + dy1} T：(x,y)+ 在当前位置和终点 x,y 之间绘制一条平滑的二次贝塞尔曲线。控制点是上一条曲线命令的控制点在当前位置上的反射点；若上一条命令不是曲线命令，则其与曲线的起始点（当前位置）相同。后续的坐标序列将被解释为隐式的绝对位置的平滑二次贝塞尔曲线（T）命令的参数。公式：Po′ = Pn = {x, y} t：(dx,dy)+ 在当前位置和终点（终点为当前位置沿 x 轴偏移 dx 以及沿 y 轴偏移 dy 处）之间绘制一条平滑的二次贝塞尔曲线。控制点是上一条曲线命令的控制点在当前位置上的反射点；若上一条命令不是曲线命令，则其与曲线的起始点（当前位置）相同。后续的坐标序列将被解释为隐式的相对位置的平滑二次贝塞尔曲线（t）命令的参数。公式：Po′ = Pn = {xo + dx, yo + dy} 简单来说 在一张白纸上，我们拿起笔，找到指定的目标位置，然后基于控制点来画一条曲线到目标点，并且到达目标点后当前节点改为新的起始点。 T是一个Q的快捷命令，一般用于画对称曲线，正弦、余弦曲线，具体就是：对上一条曲线命令的控制点在当前位置上的反射点；若上一条命令不是曲线命令，则其与曲线的起始点（当前位置）相同。 大小写命令和+表达的意思，同样的，见 MoveTo 命令。 N次贝塞尔曲线n次贝塞尔曲线则也可以联想出来，它受到了 n-1个控制点来控制。 由于高阶贝塞尔曲线没有命令，那这里以三次贝塞尔曲线为例。 同样的，配置和参数与二次贝塞尔曲线，基本一致，无非是增加了一个控制点的参数信息，还有就是命令标识符不一样了。以下是与二次贝塞尔曲线的对比： 二次贝塞尔曲线 三次贝塞尔曲线 命令 Q、q，T、t C、c，S、s 坐标对 2对坐标 3对坐标 目标坐标 最后1对是目标坐标 最后1对也是目标坐标 了解更多实例和参数信息，可以参考：三次贝塞尔曲线 椭圆曲线 MDN 文档解释 椭圆曲线是定义为椭圆的一部分的曲线。有时，使用椭圆曲线绘制高度规则的曲线会比使用贝塞尔曲线更容易。 命令 A：(rx ry angle large-arc-flag sweep-flag x y)+ 在当前位置和坐标 x,y 之间绘制一条椭圆曲线。 用于绘制圆弧的椭圆中心根据命令的其他参数确定：rx 和ry 是椭圆的两个半径；angle 表示椭圆相对于 x 轴的旋转角度；large-arc-flag 和 sweep-flag 允许选择必须绘制的弧线，因为其他参数可以绘制 4 条可能的弧线。large-arc-flag 允许选择一个大弧线（1）或一个小弧线（0），sweep-flag 允许选择一条顺时针旋转的弧线（1）或一条逆时针旋转的弧线（0）。坐标 x,y 将成为下一个命令中的当前位置。后续参数集合的序列将被解释为隐式的绝对位置的椭圆曲线（A）命令的参数。 a：(rx ry angle large-arc-flag sweep-flag dx dy)+ 在当前位置和指定位置之间绘制一条椭圆曲线。指定位置为当前位置沿 x 轴偏移 dx 以及沿 y 轴偏移 dy 处。用于绘制圆弧的椭圆中心根据命令的其他参数确定：rx 和 ry 是椭圆的两个半径；angle 表示椭圆相对于 x 轴的旋转角度；large-arc-flag 和 sweep-flag 允许选择必须绘制的弧线，因为其他参数可以绘制 4 条可能的弧线。large-arc-flag 允许选择一个大弧线（1）或一个小弧线（0），sweep-flag 允许选择一条顺时针旋转的弧线（1）或一条逆时针旋转的弧线（0）当前位置沿 x 轴偏移 dx 以及沿 y 轴偏移后的位置将成为下一个命令中的当前位置。后续参数集合的序列将被解释为隐式的相对位置的椭圆曲线（a）命令的参数。 简单来说 主要是因为参数内容比较多，但是理解之后，会很简单。 首先是两个参数rx,ry，分别表示椭圆的两个半径。然后是 angle，表示椭圆相对于 x 轴的角度，顺时针旋转。 接下来的两个参数可能会让你回忆起来高中的数学知识了，如果没有这俩参数，那么再根据目标坐标参数，可以确定 4 条可能的弧线（高中时候接触过）。 因此我们需要确定具体哪一条曲线是我们想要的： large-arc-flag 允许选择一个大弧线（1）或一个小弧线（0） sweep-flag 允许选择一条顺时针旋转的弧线（1）或一条逆时针旋转的弧线（0） 然后就是目标坐标点了，目标坐标点是落在弧线上的，因此会出现椭圆并没有完全闭合的情况。 ClosePath(封闭路径) MDN 文档解释 ClosePath 命令将从当前位置绘制一条直线到路径中的第一个点。 命令 Z，z 通过连接路径的最后一个点与路径的起始点来闭合当前的子路径。如果这两个点的坐标不同，则在两者之间绘制一条直线。 备注： 使用 ClosePath 命令闭合的形状的外观可能与使用其他命令向起始点绘制一条线而闭合的形状不同，因为前者是将线条的末端连接在一起（根据 stroke-linejoin 的设置），而不是仅仅绘制到坐标点上。 参考资料SVG可缩放矢量图形属性 d 维基百科-贝塞尔曲线","link":"/path-draw/"},{"title":"webpack的构建流程","text":"Webpack的构建流程，包括初始化参数、开始编译、确定入口、编译模块、完成模块编译、输出资源和输出完成等7个步骤。 初始化参数：从配置文件和 Shell语句中读取与合并参数，得出最终的参数 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译 确定入口：根据配置中的 entry 找出所有的入口文件 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理 完成模块编译：在经过上一步使 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统，在以上过程中，webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调Webpack 提供的 API 改变 Webpack 的运行结果","link":"/process-of-webpack/"},{"title":"webpack 中 loader 和 plugin 的不同","text":"作用不同 Loader 用于转换某些类型的模块，为其他模块提供加载支持。 提供给 webpack 加载和解析非 JavaScript 文件的一个能力 Plugin 用于改变 webpack 的打包行为。 扩展 webpack 的功能，使 webpack 拥有更多的灵活性 用法不同 Loader 是在 modules.rules 中配置的，可以作为模块的解析规则，类型是一个数组，每一项是一个对象，对象内声明了配置内容就是一个什么样类型的文件，可以使用什么样的 loader 去进行加载，以及有不同的参数 options。 Plugin 是在 跟 modules 同级的 plugins 中单独配置的，也是一个数组，但是每一项是一个插件实例，每一个插件的配置参数内容是通过构造函数传入进去的 执行时机不同在 Webpack 中，Loader 和 Plugin 的执行时间取决于它们在构建过程中所处的阶段。 Loader 主要在模块加载阶段执行，即在模块被导入时执行。Loader 的执行时间通常在构建阶段的前端部分。例如，当使用 Babel 进行代码转换时，Loader 会在构建阶段的前端部分将 JavaScript 代码转换为浏览器支持的代码。 而 Plugin 主要在构建阶段的全局阶段执行，包括构建阶段的前端部分和后端部分。例如，当使用 UglifyJS 进行代码压缩时，Plugin 会在构建阶段的后端部分将代码压缩为更小的体积。 需要注意的是，Loader 和 Plugin 的执行时间可能会因为构建配置的变化而变化。例如，如果使用了动态导入，那么 Loader 的执行时间可能会在导入时发生改变。同样，如果使用了动态加载的 Plugin，那么 Plugin 的执行时间也会在构建阶段的全局阶段发生改变。 常用的 Loader 和 Plugin file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去 source-map-loader：加载额外的 Source Map 文件以方便断点调试 image-loader：加载并且压缩图片文件 babel-loader：把 ES6 转换成 ES5 css-loader：加载 CSS，支持模块化、压缩、文件导入等特性 style-loader：把 PSS.代确法入到 paygScript 中，通过 DOM 操作去加载 CSS his loaderand our plugtn eslint-loader：通过 ESLint 检查 JavaScript 代码太常用的 plugin 以及相应的作用如下： Webpack-dashboard：可以更友好的展示相关打包信息 Webpack-merge： 提取公共配置，减少重复配置代码 speed-measure-Webpack-plugin：简称 SMP，分析出 webpack 打包过程中 Loader 和 plugin 的耗时，有助于找到构建过程中的性能瓶颈 size-plugin：监控资源体积变化，尽早发现问题 HotModuleReplacementPlugin :模块热替换","link":"/Loader-Plugin-Webpack/"},{"title":"Vue 和 React 的比较","text":"自从入了 Vue 的坑，都快忘记了 React 最近突然想起来 React，这么久没有接触，想试着玩一玩。 回想起大学时，学长们的分享，总是说 Vue 更易上手，所以就入了 Vue 的坑，但是仔细想想，自己却从来没有亲自去认真了解过 React，真是罪过… 趁此机会了解一下 React，试着把 Vue 和 React 进行一下比较。在网上找到一篇大佬的分享，觉得非常棒，文章内容很详细，链接我放到后文中。 我看完之后想简单总结性的记一下 异同点Vue 和 React 都是用于构建用户界面的 JavaScript 库，它们都提供了组件化、声明式编码等特性。它们之间有一些相似点，但也有一些区别。 相同点 都使用 Virtural DOM 都使用组件化思想，流程基本一致 都是响应式，推崇单向数据流 都有成熟的社区，都支持服务端渲染 Vue 和 React 实现原理和流程基本一致，都是使用 Virtual DOM + Diff 算法。 通用流程Vue 和 React 通用流程： vue template/react jsx render 函数 生成 VNode 当有变化时，新老 VNode diff -&gt; diff 算法对比，并真正去更新真实 DOM。 Virtual DOM为什么Vue和React都选择Virtual DOM（React 首创 VDOM，Vue2.0 开始引入 VDOM）？ 减少直接操作 DOM。框架给我们提供了屏蔽底层 dom 书写的方式，减少频繁的整更新 dom，同时也使得数据驱动视图 为函数式 UI 编程提供可能（React 核心思想） 可以跨平台，渲染到 DOM（web）之外的平台。比如 ReactNative，Weex 差异点核心思想不同Vue推崇灵活易用（渐进式开发体验），数据可变，双向数据绑定（依赖收集）。 React的函数式编程这个基本盘不会变。 组件实现不同Vue源码实现是把options挂载到Vue核心类上，然后再new Vue({options})拿到实例（vue组件的script导出的是一个挂满options的纯对象而已）。 React内部实现比较简单，直接定义render函数以生成VNode，而React内部使用了四大组件类包装VNode，不同类型的VNode使用相应的组件类处理，职责划分清晰明了（后面的Diff算法也非常清晰）。 响应式原理不同Vue依赖收集，自动优化，数据可变。Vue递归监听data的所有属性,直接修改。当数据改变时，自动找到引用组件重新渲染。 React基于状态机，手动优化，数据不可变，需要setState驱动新的State替换老的State。当数据改变时，以组件为根目录，默认全部重新渲染 diff 算法不同Vue Diff使用双向链表，边对比，边更新DOM。React主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM 事件机制不同Vue原生事件使用标准Web事件。Vue组件自定义事件机制，是父子组件通信基础。Vue合理利用了snabbdom库的模块插件 React原生事件被包装，所有事件都冒泡到顶层document监听，然后在这里合成事件下发。基于这套，可以跨端使用事件机制，而不是和Web DOM强绑定。React组件上无事件，父子组件通信使用props 参考资料个人理解Vue和React区别","link":"/comparison-between-Vue-React/"},{"title":"一个很棒的下划线css 效果","text":"最近刷视频刷到一个分享，发现是一个很棒的 css 效果：通过使用background相关属性来实现一段文本的多彩下划线样式，并且在鼠标悬浮时进行显示。 先思考一下自己可以有哪些手段来实现，然后再来了解一下这里的实现手段吧： 如图所示： 定义一个容器 12345&lt;div&gt; &lt;h2 class=&quot;title&quot;&gt; &lt;span&gt;Migrating From MySQL to YygabyteDB Using YugabyteDB Voyager&lt;/span&gt; &lt;/h2&gt;&lt;/div&gt; 增加一些样式，核心内容就是对 background属性的熟练使用，定义一个渐变背景，初始化时背景宽度为 0，背景的位置放到 rigth bottom，并且设置一个过度效果。当鼠标悬浮在文本中时，将背景宽度设置为 100%，并且将背景的位置设置为left bottom。 12345678910111213.title { color: #333; line-height: 2;}.titile span { background: linear-gradient(to right, #ec695c, #61c454) no-repeat right bottom; background-size: 0 2px; transition: background-size 1300ms;}.title span:hover { background-position-x: left; background-size: 100% 2px;} 来看一下展示效果：","link":"/amazing-underline-css/"},{"title":"function 转 class","text":"如何将下面的代码转换为普通构造函数的写法？ 12345678class Animal { constructor(name) { this.name = name } run() { console.log(this.name + ' is running!') }} 有 4 点需要注意： 严格模式 构造函数只能通过 new 关键字创建，不能够直接调用 属性方法不能够被枚举 属性方法不能够通过 new 关键字创建 123456789101112131415161718192021'use strict' // 1. 严格模式function Animal(name) { // 2. 只能通过 new 关键字创建，不能够直接调用 if (!new.target) { throw new TypeError(`Class constructor ${this.constructor.name} cannot be invoked without 'new'`) } this.name = name}Object.defineProperty(Animal.prototype, 'run', { value: function() { // 4. 不能通过 new 关键字创建 if (!new.target) { throw new TypeError(`Animal.prototype.run cannot be invoked without 'new'`) } console.log(this.name + ' is running!') }, // 3. 当前属性方法不能够枚举 enumerable: false})","link":"/function2class/"}],"tags":[{"name":"Express","slug":"Express","link":"/tags/Express/"},{"name":"Https","slug":"Https","link":"/tags/Https/"},{"name":"Node","slug":"Node","link":"/tags/Node/"},{"name":"Data Structure","slug":"Data-Structure","link":"/tags/Data-Structure/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"Electron","slug":"Electron","link":"/tags/Electron/"},{"name":"SSH","slug":"SSH","link":"/tags/SSH/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Flex","slug":"Flex","link":"/tags/Flex/"},{"name":"NVM","slug":"NVM","link":"/tags/NVM/"},{"name":"Network","slug":"Network","link":"/tags/Network/"},{"name":"Others","slug":"Others","link":"/tags/Others/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"Sublime","slug":"Sublime","link":"/tags/Sublime/"},{"name":"FTP","slug":"FTP","link":"/tags/FTP/"},{"name":"SFTP","slug":"SFTP","link":"/tags/SFTP/"},{"name":"SCP","slug":"SCP","link":"/tags/SCP/"},{"name":"Uni-app","slug":"Uni-app","link":"/tags/Uni-app/"},{"name":"Cross-domin","slug":"Cross-domin","link":"/tags/Cross-domin/"},{"name":"Axios","slug":"Axios","link":"/tags/Axios/"},{"name":"Win10","slug":"Win10","link":"/tags/Win10/"},{"name":"NPM","slug":"NPM","link":"/tags/NPM/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"RegExp","slug":"RegExp","link":"/tags/RegExp/"},{"name":"Svg","slug":"Svg","link":"/tags/Svg/"},{"name":"Path","slug":"Path","link":"/tags/Path/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"Generator","slug":"Generator","link":"/tags/Generator/"},{"name":"React","slug":"React","link":"/tags/React/"}],"categories":[{"name":"Config Share","slug":"Config-Share","link":"/categories/Config-Share/"},{"name":"Course Notes","slug":"Course-Notes","link":"/categories/Course-Notes/"},{"name":"Study Share","slug":"Study-Share","link":"/categories/Study-Share/"},{"name":"Front-end Study","slug":"Front-end-Study","link":"/categories/Front-end-Study/"},{"name":"DevOps Record","slug":"DevOps-Record","link":"/categories/DevOps-Record/"},{"name":"Front-end-Study","slug":"Front-end-Study","link":"/categories/Front-end-Study/"}]}